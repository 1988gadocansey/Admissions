//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAddressClient {
    create(command: CreateAddressRequest): Observable<number>;
    get(): Observable<AddressDto>;
}

@Injectable({
    providedIn: 'root'
})
export class AddressClient implements IAddressClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateAddressRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/Address";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(): Observable<AddressDto> {
        let url_ = this.baseUrl + "/api/Address";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IApplicantClient {
    get(): Observable<ApplicantVm>;
    getForms(): Observable<ApplicationType[]>;
    saveFormChanges(command: CreateFormUpdateRequest): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ApplicantClient implements IApplicantClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<ApplicantVm> {
        let url_ = this.baseUrl + "/api/Applicant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicantVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicantVm>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ApplicantVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicantVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getForms(): Observable<ApplicationType[]> {
        let url_ = this.baseUrl + "/api/Applicant/form/change";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationType[]>;
        }));
    }

    protected processGetForms(response: HttpResponseBase): Observable<ApplicationType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveFormChanges(command: CreateFormUpdateRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Applicant/form/change";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFormChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFormChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSaveFormChanges(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBiodataClient {
    create(command: CreateBiodataRequest): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class BiodataClient implements IBiodataClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateBiodataRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/Biodata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IDocumentUploadClient {
    create(command: UploadDocumentRequest): Observable<number>;
    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfDocumentUploadDto>;
}

@Injectable({
    providedIn: 'root'
})
export class DocumentUploadClient implements IDocumentUploadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: UploadDocumentRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/DocumentUpload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfDocumentUploadDto> {
        let url_ = this.baseUrl + "/api/DocumentUpload?";
        if (resultId === null)
            throw new Error("The parameter 'resultId' cannot be null.");
        else if (resultId !== undefined)
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfDocumentUploadDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfDocumentUploadDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfDocumentUploadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfDocumentUploadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEducationalBackendClient {
    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfSHSAttendedDto>;
    create(command: SHSAttendedRequest): Observable<number>;
    delete(id: number): Observable<FileResponse>;
    getUniversity(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfUniversityAttendedDto>;
    createUniversity(command: UniversityAttendedRequest): Observable<number>;
    deleteUniversity(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class EducationalBackendClient implements IEducationalBackendClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfSHSAttendedDto> {
        let url_ = this.baseUrl + "/api/EducationalBackend/get/shs?";
        if (resultId === null)
            throw new Error("The parameter 'resultId' cannot be null.");
        else if (resultId !== undefined)
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfSHSAttendedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfSHSAttendedDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfSHSAttendedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfSHSAttendedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: SHSAttendedRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/EducationalBackend/post/shs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/EducationalBackend/delete/shs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUniversity(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfUniversityAttendedDto> {
        let url_ = this.baseUrl + "/api/EducationalBackend/get/universityattended?";
        if (resultId === null)
            throw new Error("The parameter 'resultId' cannot be null.");
        else if (resultId !== undefined)
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUniversity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUniversity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfUniversityAttendedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfUniversityAttendedDto>;
        }));
    }

    protected processGetUniversity(response: HttpResponseBase): Observable<PaginatedListOfUniversityAttendedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfUniversityAttendedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createUniversity(command: UniversityAttendedRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/EducationalBackend/post/universityattended";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUniversity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUniversity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateUniversity(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteUniversity(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/EducationalBackend/delete/universityattended/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUniversity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUniversity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteUniversity(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IHomeClient {
    dashboard(): Observable<UserDto>;
    getGrade(): Observable<number>;
    getProgress(): Observable<ProgressDto>;
}

@Injectable({
    providedIn: 'root'
})
export class HomeClient implements IHomeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    dashboard(): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/Home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processDashboard(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getGrade(): Observable<number> {
        let url_ = this.baseUrl + "/api/Home/grade";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGrade(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGrade(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetGrade(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProgress(): Observable<ProgressDto> {
        let url_ = this.baseUrl + "/api/Home/progress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProgressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProgressDto>;
        }));
    }

    protected processGetProgress(response: HttpResponseBase): Observable<ProgressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPictureUploadClient {
    uploadImages(formFiles: FileParameter[] | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class PictureUploadClient implements IPictureUploadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    uploadImages(formFiles: FileParameter[] | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PictureUpload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFiles !== null && formFiles !== undefined)
            formFiles.forEach(item_ => content_.append("formFiles", item_.data, item_.fileName ? item_.fileName : "formFiles") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadImages(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPreviewClient {
    dashboard(): Observable<ApplicantVm>;
}

@Injectable({
    providedIn: 'root'
})
export class PreviewClient implements IPreviewClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    dashboard(): Observable<ApplicantVm> {
        let url_ = this.baseUrl + "/api/Preview/preview";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicantVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicantVm>;
        }));
    }

    protected processDashboard(response: HttpResponseBase): Observable<ApplicantVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicantVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProgrammeInformationClient {
    create(command: ProgrammeInfoRequest): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class ProgrammeInformationClient implements IProgrammeInformationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: ProgrammeInfoRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/ProgrammeInformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRefereeClient {
    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfRefereeDto>;
    create(command: CreateRefereeRequest): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RefereeClient implements IRefereeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfRefereeDto> {
        let url_ = this.baseUrl + "/api/Referee?";
        if (resultId === null)
            throw new Error("The parameter 'resultId' cannot be null.");
        else if (resultId !== undefined)
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfRefereeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfRefereeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfRefereeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfRefereeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateRefereeRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/Referee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Referee/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IResearchExperienceClient {
    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfResearchExperienceDto>;
    create(command: ResearchExperienceRequest): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ResearchExperienceClient implements IResearchExperienceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfResearchExperienceDto> {
        let url_ = this.baseUrl + "/api/ResearchExperience?";
        if (resultId === null)
            throw new Error("The parameter 'resultId' cannot be null.");
        else if (resultId !== undefined)
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfResearchExperienceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfResearchExperienceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfResearchExperienceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfResearchExperienceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: ResearchExperienceRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/ResearchExperience";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ResearchExperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IResearchPublicationClient {
    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfResearchPublicationDto>;
    create(command: ResearchPublicationRequest): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ResearchPublicationClient implements IResearchPublicationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfResearchPublicationDto> {
        let url_ = this.baseUrl + "/api/ResearchPublication?";
        if (resultId === null)
            throw new Error("The parameter 'resultId' cannot be null.");
        else if (resultId !== undefined)
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfResearchPublicationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfResearchPublicationDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfResearchPublicationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfResearchPublicationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: ResearchPublicationRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/ResearchPublication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ResearchPublication/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IResultUploadClient {
    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfResultsDto>;
    create(command: CreateResultRequest): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ResultUploadClient implements IResultUploadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfResultsDto> {
        let url_ = this.baseUrl + "/api/ResultUpload?";
        if (resultId === null)
            throw new Error("The parameter 'resultId' cannot be null.");
        else if (resultId !== undefined)
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfResultsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfResultsDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfResultsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfResultsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateResultRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/ResultUpload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ResultUpload/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISelectBoxClient {
    getReligions(): Observable<ReligionDto[]>;
    getRegions(): Observable<RegionDto[]>;
    getDisabilities(): Observable<string[]>;
    getDenominations(): Observable<DenominationDto[]>;
    getProgrammes(): Observable<ProgrammeDto[]>;
    getLanguages(): Observable<LanguageDto[]>;
    getSchools(): Observable<FormerSchoolDto[]>;
    getDistricts(): Observable<DistrictDto[]>;
    getCountries(): Observable<CountryDto[]>;
    getGrades(): Observable<GradeDto[]>;
    getExams(): Observable<ExamDto[]>;
    getSubjects(): Observable<SubjectDto[]>;
    getSHSProgrammes(): Observable<SHSProgrammesDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class SelectBoxClient implements ISelectBoxClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getReligions(): Observable<ReligionDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/religions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReligions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReligions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReligionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReligionDto[]>;
        }));
    }

    protected processGetReligions(response: HttpResponseBase): Observable<ReligionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReligionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRegions(): Observable<RegionDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/regions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionDto[]>;
        }));
    }

    protected processGetRegions(response: HttpResponseBase): Observable<RegionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDisabilities(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/SelectBox/disabilities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDisabilities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDisabilities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetDisabilities(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDenominations(): Observable<DenominationDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/denominations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDenominations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDenominations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DenominationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DenominationDto[]>;
        }));
    }

    protected processGetDenominations(response: HttpResponseBase): Observable<DenominationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DenominationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProgrammes(): Observable<ProgrammeDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/programmes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgrammes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgrammes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProgrammeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProgrammeDto[]>;
        }));
    }

    protected processGetProgrammes(response: HttpResponseBase): Observable<ProgrammeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgrammeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLanguages(): Observable<LanguageDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/languages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageDto[]>;
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<LanguageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSchools(): Observable<FormerSchoolDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/schools";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchools(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchools(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FormerSchoolDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FormerSchoolDto[]>;
        }));
    }

    protected processGetSchools(response: HttpResponseBase): Observable<FormerSchoolDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FormerSchoolDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDistricts(): Observable<DistrictDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/districts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistricts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistricts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DistrictDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DistrictDto[]>;
        }));
    }

    protected processGetDistricts(response: HttpResponseBase): Observable<DistrictDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DistrictDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getGrades(): Observable<GradeDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/grades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGrades(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GradeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GradeDto[]>;
        }));
    }

    protected processGetGrades(response: HttpResponseBase): Observable<GradeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GradeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getExams(): Observable<ExamDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/exams";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExams(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamDto[]>;
        }));
    }

    protected processGetExams(response: HttpResponseBase): Observable<ExamDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExamDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubjects(): Observable<SubjectDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/subjects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubjectDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubjectDto[]>;
        }));
    }

    protected processGetSubjects(response: HttpResponseBase): Observable<SubjectDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubjectDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSHSProgrammes(): Observable<SHSProgrammesDto[]> {
        let url_ = this.baseUrl + "/api/SelectBox/shsprogramme";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSHSProgrammes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSHSProgrammes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SHSProgrammesDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SHSProgrammesDto[]>;
        }));
    }

    protected processGetSHSProgrammes(response: HttpResponseBase): Observable<SHSProgrammesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SHSProgrammesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITodoItemsClient {
    getTodoItemsWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTodoItemBriefDto>;
    create(command: CreateTodoItemCommand): Observable<number>;
    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoItemsClient implements ITodoItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTodoItemsWithPagination(listId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfTodoItemBriefDto> {
        let url_ = this.baseUrl + "/api/TodoItems?";
        if (listId === null)
            throw new Error("The parameter 'listId' cannot be null.");
        else if (listId !== undefined)
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTodoItemsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTodoItemsWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTodoItemBriefDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTodoItemBriefDto>;
        }));
    }

    protected processGetTodoItemsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfTodoItemBriefDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTodoItemBriefDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTodoItemCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateItemDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITodoListsClient {
    get(): Observable<TodosVm>;
    create(command: CreateTodoListCommand): Observable<number>;
    get2(id: number): Observable<FileResponse>;
    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoListsClient implements ITodoListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TodosVm>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TodosVm>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TodosVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTodoListCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get2(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWorkingExperienceClient {
    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfWorkingExperienceDto>;
    create(command: WorkingExperienceRequest): Observable<number>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class WorkingExperienceClient implements IWorkingExperienceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(resultId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfWorkingExperienceDto> {
        let url_ = this.baseUrl + "/api/WorkingExperience?";
        if (resultId === null)
            throw new Error("The parameter 'resultId' cannot be null.");
        else if (resultId !== undefined)
            url_ += "ResultId=" + encodeURIComponent("" + resultId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfWorkingExperienceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfWorkingExperienceDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfWorkingExperienceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWorkingExperienceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: WorkingExperienceRequest): Observable<number> {
        let url_ = this.baseUrl + "/api/WorkingExperience";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/WorkingExperience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherForecastClient {
    get(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class CreateAddressRequest implements ICreateAddressRequest {
    id?: number | undefined;
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
    applicant?: number;

    constructor(data?: ICreateAddressRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.street = _data["street"];
            this.houseNumber = _data["houseNumber"];
            this.city = _data["city"];
            this.gprs = _data["gprs"];
            this.box = _data["box"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): CreateAddressRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAddressRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["street"] = this.street;
        data["houseNumber"] = this.houseNumber;
        data["city"] = this.city;
        data["gprs"] = this.gprs;
        data["box"] = this.box;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface ICreateAddressRequest {
    id?: number | undefined;
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
    applicant?: number;
}

export class AddressDto implements IAddressDto {
    id?: number;
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
    applicant?: ApplicantModel | undefined;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.street = _data["street"];
            this.houseNumber = _data["houseNumber"];
            this.city = _data["city"];
            this.gprs = _data["gprs"];
            this.box = _data["box"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["street"] = this.street;
        data["houseNumber"] = this.houseNumber;
        data["city"] = this.city;
        data["gprs"] = this.gprs;
        data["box"] = this.box;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddressDto {
    id?: number;
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
    applicant?: ApplicantModel | undefined;
}

export abstract class BaseEntity implements IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                this.domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    this.domainEvents!.push(BaseEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];
}

export abstract class BaseAuditableEntity extends BaseEntity implements IBaseAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IBaseAuditableEntity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static override fromJS(data: any): BaseAuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseAuditableEntity' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseAuditableEntity extends IBaseEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class ApplicantModel extends BaseAuditableEntity implements IApplicantModel {
    applicationNumber?: ApplicationNumber;
    title?: Title;
    applicantName?: ApplicantName;
    previousName?: ApplicantName | undefined;
    dob?: Date;
    gender?: Gender;
    age?: number;
    maritalStatus?: MaritalStatus | undefined;
    noOfChildren?: number | undefined;
    phone?: PhoneNumber;
    altPhone?: PhoneNumber | undefined;
    email?: EmailAddress;
    postGPRS?: string | undefined;
    emergencyContact?: PhoneNumber | undefined;
    hometown?: string | undefined;
    districtId?: number | undefined;
    district?: DistrictModel | undefined;
    hall?: HallModel | undefined;
    idcard?: IDCard | undefined;
    regionId?: number | undefined;
    region?: RegionModel | undefined;
    nationalityId?: number | undefined;
    nationality?: CountryModel | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: PhoneNumber;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability | undefined;
    sourceOfFinance?: string | undefined;
    religionId?: number | undefined;
    religion?: ReligionModel | undefined;
    denomination?: string | undefined;
    referrals?: string | undefined;
    entryMode?: Session | undefined;
    firstQualification?: EntryQualification | undefined;
    secondQualification?: EntryQualification | undefined;
    programmeStudied?: string | undefined;
    formerSchool?: string | undefined;
    formerSchoolNewId?: number | undefined;
    formerSchoolNew?: FormerSchoolModel | undefined;
    programmeAdmittedId?: number | undefined;
    lastYearInSchool?: number | undefined;
    awaiting?: boolean | undefined;
    grade?: number | undefined;
    yearOfAdmission?: string | undefined;
    preferedHall?: string | undefined;
    results?: string | undefined;
    externalHostel?: string | undefined;
    elligible?: boolean | undefined;
    admitted?: boolean | undefined;
    admittedBy?: number | undefined;
    dateAdmitted?: Date | undefined;
    admissionType?: AdmissionType | undefined;
    leveladmitted?: string | undefined;
    sectionAdmitted?: string | undefined;
    hallAdmitted?: number | undefined;
    roomNo?: string | undefined;
    status?: ApplicationStatus | undefined;
    smsSent?: boolean | undefined;
    letterPrinted?: boolean | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    feePaying?: boolean | undefined;
    reportedInSchool?: boolean | undefined;
    feesPaid?: Money | undefined;
    hallFeesPaid?: Money | undefined;
    reported?: boolean | undefined;
    sponsorShip?: boolean | undefined;
    sponsorShipCompany?: string | undefined;
    sponsorShipLocation?: string | undefined;
    sponsorShipCompanyContact?: string | undefined;
    applicationUserId?: string | undefined;
    getFullName?: string;
    programmes?: ProgrammeModel[];
    resultUploads?: ResultUploadModel[];
    workingExperiences?: (WorkingExperienceModel | undefined)[];
    academicExperiences?: (AcademicExperienceModel | undefined)[];
    documents?: (DocumentUploadModel | undefined)[];
    referees?: (RefereeModel | undefined)[];
    addresses?: (AddressModel | undefined)[];
    languages?: (LanguageModel | undefined)[];
    sms?: SMSModel[];
    applicantIssues?: ApplicantIssueModel[] | undefined;
    researchModels?: ResearchModel[] | undefined;
    researchPublications?: ResearchPublicationModel[] | undefined;
    universityAttended?: UniversityAttendedModel[] | undefined;
    shsAttend?: SHSAttendedModel[] | undefined;
    disabilities?: DisabilitiesModel[] | undefined;

    constructor(data?: IApplicantModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applicationNumber = _data["applicationNumber"] ? ApplicationNumber.fromJS(_data["applicationNumber"]) : <any>undefined;
            this.title = _data["title"];
            this.applicantName = _data["applicantName"] ? ApplicantName.fromJS(_data["applicantName"]) : <any>undefined;
            this.previousName = _data["previousName"] ? ApplicantName.fromJS(_data["previousName"]) : <any>undefined;
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.age = _data["age"];
            this.maritalStatus = _data["maritalStatus"];
            this.noOfChildren = _data["noOfChildren"];
            this.phone = _data["phone"] ? PhoneNumber.fromJS(_data["phone"]) : <any>undefined;
            this.altPhone = _data["altPhone"] ? PhoneNumber.fromJS(_data["altPhone"]) : <any>undefined;
            this.email = _data["email"] ? EmailAddress.fromJS(_data["email"]) : <any>undefined;
            this.postGPRS = _data["postGPRS"];
            this.emergencyContact = _data["emergencyContact"] ? PhoneNumber.fromJS(_data["emergencyContact"]) : <any>undefined;
            this.hometown = _data["hometown"];
            this.districtId = _data["districtId"];
            this.district = _data["district"] ? DistrictModel.fromJS(_data["district"]) : <any>undefined;
            this.hall = _data["hall"] ? HallModel.fromJS(_data["hall"]) : <any>undefined;
            this.idcard = _data["idcard"] ? IDCard.fromJS(_data["idcard"]) : <any>undefined;
            this.regionId = _data["regionId"];
            this.region = _data["region"] ? RegionModel.fromJS(_data["region"]) : <any>undefined;
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? CountryModel.fromJS(_data["nationality"]) : <any>undefined;
            this.residentialStatus = _data["residentialStatus"];
            this.guardianName = _data["guardianName"];
            this.guardianPhone = _data["guardianPhone"] ? PhoneNumber.fromJS(_data["guardianPhone"]) : <any>undefined;
            this.guardianOccupation = _data["guardianOccupation"];
            this.guardianRelationship = _data["guardianRelationship"];
            this.disability = _data["disability"];
            this.disabilityType = _data["disabilityType"];
            this.sourceOfFinance = _data["sourceOfFinance"];
            this.religionId = _data["religionId"];
            this.religion = _data["religion"] ? ReligionModel.fromJS(_data["religion"]) : <any>undefined;
            this.denomination = _data["denomination"];
            this.referrals = _data["referrals"];
            this.entryMode = _data["entryMode"];
            this.firstQualification = _data["firstQualification"];
            this.secondQualification = _data["secondQualification"];
            this.programmeStudied = _data["programmeStudied"];
            this.formerSchool = _data["formerSchool"];
            this.formerSchoolNewId = _data["formerSchoolNewId"];
            this.formerSchoolNew = _data["formerSchoolNew"] ? FormerSchoolModel.fromJS(_data["formerSchoolNew"]) : <any>undefined;
            this.programmeAdmittedId = _data["programmeAdmittedId"];
            this.lastYearInSchool = _data["lastYearInSchool"];
            this.awaiting = _data["awaiting"];
            this.grade = _data["grade"];
            this.yearOfAdmission = _data["yearOfAdmission"];
            this.preferedHall = _data["preferedHall"];
            this.results = _data["results"];
            this.externalHostel = _data["externalHostel"];
            this.elligible = _data["elligible"];
            this.admitted = _data["admitted"];
            this.admittedBy = _data["admittedBy"];
            this.dateAdmitted = _data["dateAdmitted"] ? new Date(_data["dateAdmitted"].toString()) : <any>undefined;
            this.admissionType = _data["admissionType"];
            this.leveladmitted = _data["leveladmitted"];
            this.sectionAdmitted = _data["sectionAdmitted"];
            this.hallAdmitted = _data["hallAdmitted"];
            this.roomNo = _data["roomNo"];
            this.status = _data["status"];
            this.smsSent = _data["smsSent"];
            this.letterPrinted = _data["letterPrinted"];
            this.firstChoiceId = _data["firstChoiceId"];
            this.secondChoiceId = _data["secondChoiceId"];
            this.thirdChoiceId = _data["thirdChoiceId"];
            this.feePaying = _data["feePaying"];
            this.reportedInSchool = _data["reportedInSchool"];
            this.feesPaid = _data["feesPaid"] ? Money.fromJS(_data["feesPaid"]) : <any>undefined;
            this.hallFeesPaid = _data["hallFeesPaid"] ? Money.fromJS(_data["hallFeesPaid"]) : <any>undefined;
            this.reported = _data["reported"];
            this.sponsorShip = _data["sponsorShip"];
            this.sponsorShipCompany = _data["sponsorShipCompany"];
            this.sponsorShipLocation = _data["sponsorShipLocation"];
            this.sponsorShipCompanyContact = _data["sponsorShipCompanyContact"];
            this.applicationUserId = _data["applicationUserId"];
            this.getFullName = _data["getFullName"];
            if (Array.isArray(_data["programmes"])) {
                this.programmes = [] as any;
                for (let item of _data["programmes"])
                    this.programmes!.push(ProgrammeModel.fromJS(item));
            }
            if (Array.isArray(_data["resultUploads"])) {
                this.resultUploads = [] as any;
                for (let item of _data["resultUploads"])
                    this.resultUploads!.push(ResultUploadModel.fromJS(item));
            }
            if (Array.isArray(_data["workingExperiences"])) {
                this.workingExperiences = [] as any;
                for (let item of _data["workingExperiences"])
                    this.workingExperiences!.push(WorkingExperienceModel.fromJS(item));
            }
            if (Array.isArray(_data["academicExperiences"])) {
                this.academicExperiences = [] as any;
                for (let item of _data["academicExperiences"])
                    this.academicExperiences!.push(AcademicExperienceModel.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentUploadModel.fromJS(item));
            }
            if (Array.isArray(_data["referees"])) {
                this.referees = [] as any;
                for (let item of _data["referees"])
                    this.referees!.push(RefereeModel.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(AddressModel.fromJS(item));
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageModel.fromJS(item));
            }
            if (Array.isArray(_data["sms"])) {
                this.sms = [] as any;
                for (let item of _data["sms"])
                    this.sms!.push(SMSModel.fromJS(item));
            }
            if (Array.isArray(_data["applicantIssues"])) {
                this.applicantIssues = [] as any;
                for (let item of _data["applicantIssues"])
                    this.applicantIssues!.push(ApplicantIssueModel.fromJS(item));
            }
            if (Array.isArray(_data["researchModels"])) {
                this.researchModels = [] as any;
                for (let item of _data["researchModels"])
                    this.researchModels!.push(ResearchModel.fromJS(item));
            }
            if (Array.isArray(_data["researchPublications"])) {
                this.researchPublications = [] as any;
                for (let item of _data["researchPublications"])
                    this.researchPublications!.push(ResearchPublicationModel.fromJS(item));
            }
            if (Array.isArray(_data["universityAttended"])) {
                this.universityAttended = [] as any;
                for (let item of _data["universityAttended"])
                    this.universityAttended!.push(UniversityAttendedModel.fromJS(item));
            }
            if (Array.isArray(_data["shsAttend"])) {
                this.shsAttend = [] as any;
                for (let item of _data["shsAttend"])
                    this.shsAttend!.push(SHSAttendedModel.fromJS(item));
            }
            if (Array.isArray(_data["disabilities"])) {
                this.disabilities = [] as any;
                for (let item of _data["disabilities"])
                    this.disabilities!.push(DisabilitiesModel.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ApplicantModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicantModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationNumber"] = this.applicationNumber ? this.applicationNumber.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["applicantName"] = this.applicantName ? this.applicantName.toJSON() : <any>undefined;
        data["previousName"] = this.previousName ? this.previousName.toJSON() : <any>undefined;
        data["dob"] = this.dob ? formatDate(this.dob) : <any>undefined;
        data["gender"] = this.gender;
        data["age"] = this.age;
        data["maritalStatus"] = this.maritalStatus;
        data["noOfChildren"] = this.noOfChildren;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["altPhone"] = this.altPhone ? this.altPhone.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["postGPRS"] = this.postGPRS;
        data["emergencyContact"] = this.emergencyContact ? this.emergencyContact.toJSON() : <any>undefined;
        data["hometown"] = this.hometown;
        data["districtId"] = this.districtId;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["hall"] = this.hall ? this.hall.toJSON() : <any>undefined;
        data["idcard"] = this.idcard ? this.idcard.toJSON() : <any>undefined;
        data["regionId"] = this.regionId;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["residentialStatus"] = this.residentialStatus;
        data["guardianName"] = this.guardianName;
        data["guardianPhone"] = this.guardianPhone ? this.guardianPhone.toJSON() : <any>undefined;
        data["guardianOccupation"] = this.guardianOccupation;
        data["guardianRelationship"] = this.guardianRelationship;
        data["disability"] = this.disability;
        data["disabilityType"] = this.disabilityType;
        data["sourceOfFinance"] = this.sourceOfFinance;
        data["religionId"] = this.religionId;
        data["religion"] = this.religion ? this.religion.toJSON() : <any>undefined;
        data["denomination"] = this.denomination;
        data["referrals"] = this.referrals;
        data["entryMode"] = this.entryMode;
        data["firstQualification"] = this.firstQualification;
        data["secondQualification"] = this.secondQualification;
        data["programmeStudied"] = this.programmeStudied;
        data["formerSchool"] = this.formerSchool;
        data["formerSchoolNewId"] = this.formerSchoolNewId;
        data["formerSchoolNew"] = this.formerSchoolNew ? this.formerSchoolNew.toJSON() : <any>undefined;
        data["programmeAdmittedId"] = this.programmeAdmittedId;
        data["lastYearInSchool"] = this.lastYearInSchool;
        data["awaiting"] = this.awaiting;
        data["grade"] = this.grade;
        data["yearOfAdmission"] = this.yearOfAdmission;
        data["preferedHall"] = this.preferedHall;
        data["results"] = this.results;
        data["externalHostel"] = this.externalHostel;
        data["elligible"] = this.elligible;
        data["admitted"] = this.admitted;
        data["admittedBy"] = this.admittedBy;
        data["dateAdmitted"] = this.dateAdmitted ? this.dateAdmitted.toISOString() : <any>undefined;
        data["admissionType"] = this.admissionType;
        data["leveladmitted"] = this.leveladmitted;
        data["sectionAdmitted"] = this.sectionAdmitted;
        data["hallAdmitted"] = this.hallAdmitted;
        data["roomNo"] = this.roomNo;
        data["status"] = this.status;
        data["smsSent"] = this.smsSent;
        data["letterPrinted"] = this.letterPrinted;
        data["firstChoiceId"] = this.firstChoiceId;
        data["secondChoiceId"] = this.secondChoiceId;
        data["thirdChoiceId"] = this.thirdChoiceId;
        data["feePaying"] = this.feePaying;
        data["reportedInSchool"] = this.reportedInSchool;
        data["feesPaid"] = this.feesPaid ? this.feesPaid.toJSON() : <any>undefined;
        data["hallFeesPaid"] = this.hallFeesPaid ? this.hallFeesPaid.toJSON() : <any>undefined;
        data["reported"] = this.reported;
        data["sponsorShip"] = this.sponsorShip;
        data["sponsorShipCompany"] = this.sponsorShipCompany;
        data["sponsorShipLocation"] = this.sponsorShipLocation;
        data["sponsorShipCompanyContact"] = this.sponsorShipCompanyContact;
        data["applicationUserId"] = this.applicationUserId;
        data["getFullName"] = this.getFullName;
        if (Array.isArray(this.programmes)) {
            data["programmes"] = [];
            for (let item of this.programmes)
                data["programmes"].push(item.toJSON());
        }
        if (Array.isArray(this.resultUploads)) {
            data["resultUploads"] = [];
            for (let item of this.resultUploads)
                data["resultUploads"].push(item.toJSON());
        }
        if (Array.isArray(this.workingExperiences)) {
            data["workingExperiences"] = [];
            for (let item of this.workingExperiences)
                data["workingExperiences"].push(item.toJSON());
        }
        if (Array.isArray(this.academicExperiences)) {
            data["academicExperiences"] = [];
            for (let item of this.academicExperiences)
                data["academicExperiences"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.referees)) {
            data["referees"] = [];
            for (let item of this.referees)
                data["referees"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.sms)) {
            data["sms"] = [];
            for (let item of this.sms)
                data["sms"].push(item.toJSON());
        }
        if (Array.isArray(this.applicantIssues)) {
            data["applicantIssues"] = [];
            for (let item of this.applicantIssues)
                data["applicantIssues"].push(item.toJSON());
        }
        if (Array.isArray(this.researchModels)) {
            data["researchModels"] = [];
            for (let item of this.researchModels)
                data["researchModels"].push(item.toJSON());
        }
        if (Array.isArray(this.researchPublications)) {
            data["researchPublications"] = [];
            for (let item of this.researchPublications)
                data["researchPublications"].push(item.toJSON());
        }
        if (Array.isArray(this.universityAttended)) {
            data["universityAttended"] = [];
            for (let item of this.universityAttended)
                data["universityAttended"].push(item.toJSON());
        }
        if (Array.isArray(this.shsAttend)) {
            data["shsAttend"] = [];
            for (let item of this.shsAttend)
                data["shsAttend"].push(item.toJSON());
        }
        if (Array.isArray(this.disabilities)) {
            data["disabilities"] = [];
            for (let item of this.disabilities)
                data["disabilities"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IApplicantModel extends IBaseAuditableEntity {
    applicationNumber?: ApplicationNumber;
    title?: Title;
    applicantName?: ApplicantName;
    previousName?: ApplicantName | undefined;
    dob?: Date;
    gender?: Gender;
    age?: number;
    maritalStatus?: MaritalStatus | undefined;
    noOfChildren?: number | undefined;
    phone?: PhoneNumber;
    altPhone?: PhoneNumber | undefined;
    email?: EmailAddress;
    postGPRS?: string | undefined;
    emergencyContact?: PhoneNumber | undefined;
    hometown?: string | undefined;
    districtId?: number | undefined;
    district?: DistrictModel | undefined;
    hall?: HallModel | undefined;
    idcard?: IDCard | undefined;
    regionId?: number | undefined;
    region?: RegionModel | undefined;
    nationalityId?: number | undefined;
    nationality?: CountryModel | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: PhoneNumber;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability | undefined;
    sourceOfFinance?: string | undefined;
    religionId?: number | undefined;
    religion?: ReligionModel | undefined;
    denomination?: string | undefined;
    referrals?: string | undefined;
    entryMode?: Session | undefined;
    firstQualification?: EntryQualification | undefined;
    secondQualification?: EntryQualification | undefined;
    programmeStudied?: string | undefined;
    formerSchool?: string | undefined;
    formerSchoolNewId?: number | undefined;
    formerSchoolNew?: FormerSchoolModel | undefined;
    programmeAdmittedId?: number | undefined;
    lastYearInSchool?: number | undefined;
    awaiting?: boolean | undefined;
    grade?: number | undefined;
    yearOfAdmission?: string | undefined;
    preferedHall?: string | undefined;
    results?: string | undefined;
    externalHostel?: string | undefined;
    elligible?: boolean | undefined;
    admitted?: boolean | undefined;
    admittedBy?: number | undefined;
    dateAdmitted?: Date | undefined;
    admissionType?: AdmissionType | undefined;
    leveladmitted?: string | undefined;
    sectionAdmitted?: string | undefined;
    hallAdmitted?: number | undefined;
    roomNo?: string | undefined;
    status?: ApplicationStatus | undefined;
    smsSent?: boolean | undefined;
    letterPrinted?: boolean | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    feePaying?: boolean | undefined;
    reportedInSchool?: boolean | undefined;
    feesPaid?: Money | undefined;
    hallFeesPaid?: Money | undefined;
    reported?: boolean | undefined;
    sponsorShip?: boolean | undefined;
    sponsorShipCompany?: string | undefined;
    sponsorShipLocation?: string | undefined;
    sponsorShipCompanyContact?: string | undefined;
    applicationUserId?: string | undefined;
    getFullName?: string;
    programmes?: ProgrammeModel[];
    resultUploads?: ResultUploadModel[];
    workingExperiences?: (WorkingExperienceModel | undefined)[];
    academicExperiences?: (AcademicExperienceModel | undefined)[];
    documents?: (DocumentUploadModel | undefined)[];
    referees?: (RefereeModel | undefined)[];
    addresses?: (AddressModel | undefined)[];
    languages?: (LanguageModel | undefined)[];
    sms?: SMSModel[];
    applicantIssues?: ApplicantIssueModel[] | undefined;
    researchModels?: ResearchModel[] | undefined;
    researchPublications?: ResearchPublicationModel[] | undefined;
    universityAttended?: UniversityAttendedModel[] | undefined;
    shsAttend?: SHSAttendedModel[] | undefined;
    disabilities?: DisabilitiesModel[] | undefined;
}

export abstract class ValueObject implements IValueObject {

    constructor(data?: IValueObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ValueObject {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ValueObject' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IValueObject {
}

export class ApplicationNumber extends ValueObject implements IApplicationNumber {
    applicantNumber?: number;

    constructor(data?: IApplicationNumber) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applicantNumber = _data["applicantNumber"];
        }
    }

    static override fromJS(data: any): ApplicationNumber {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationNumber();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicantNumber"] = this.applicantNumber;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationNumber extends IValueObject {
    applicantNumber?: number;
}

export enum Title {
    Mr = 0,
    Miss = 1,
    Mrs = 2,
    Rev = 3,
    Dr = 4,
    PhD = 5,
    Imam = 6,
    Prof = 7,
}

export class ApplicantName extends ValueObject implements IApplicantName {
    firstName?: string;
    lastName?: string;
    othernames?: string | undefined;

    constructor(data?: IApplicantName) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.othernames = _data["othernames"];
        }
    }

    static override fromJS(data: any): ApplicantName {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicantName();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["othernames"] = this.othernames;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicantName extends IValueObject {
    firstName?: string;
    lastName?: string;
    othernames?: string | undefined;
}

export enum Gender {
    Male = 0,
    Female = 1,
}

export enum MaritalStatus {
    Married = 0,
    Divorced = 1,
    Single = 2,
    Seperated = 3,
}

export class PhoneNumber extends ValueObject implements IPhoneNumber {
    areaCode?: string;
    number?: string;

    constructor(data?: IPhoneNumber) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.areaCode = _data["areaCode"];
            this.number = _data["number"];
        }
    }

    static override fromJS(data: any): PhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumber();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaCode"] = this.areaCode;
        data["number"] = this.number;
        super.toJSON(data);
        return data;
    }
}

export interface IPhoneNumber extends IValueObject {
    areaCode?: string;
    number?: string;
}

export class EmailAddress extends ValueObject implements IEmailAddress {
    value?: string;

    constructor(data?: IEmailAddress) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): EmailAddress {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAddress();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IEmailAddress extends IValueObject {
    value?: string;
}

export class DistrictModel implements IDistrictModel {
    id?: number;
    name?: string;
    region?: number;

    constructor(data?: IDistrictModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): DistrictModel {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["region"] = this.region;
        return data;
    }
}

export interface IDistrictModel {
    id?: number;
    name?: string;
    region?: number;
}

export class HallModel implements IHallModel {
    id?: number;
    bankAcc?: number;
    fees?: number;
    name?: string;

    constructor(data?: IHallModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankAcc = _data["bankAcc"];
            this.fees = _data["fees"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): HallModel {
        data = typeof data === 'object' ? data : {};
        let result = new HallModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankAcc"] = this.bankAcc;
        data["fees"] = this.fees;
        data["name"] = this.name;
        return data;
    }
}

export interface IHallModel {
    id?: number;
    bankAcc?: number;
    fees?: number;
    name?: string;
}

export class IDCard extends ValueObject implements IIDCard {
    nationalIDType?: string;
    nationalIDNo?: string;

    constructor(data?: IIDCard) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nationalIDType = _data["nationalIDType"];
            this.nationalIDNo = _data["nationalIDNo"];
        }
    }

    static override fromJS(data: any): IDCard {
        data = typeof data === 'object' ? data : {};
        let result = new IDCard();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nationalIDType"] = this.nationalIDType;
        data["nationalIDNo"] = this.nationalIDNo;
        super.toJSON(data);
        return data;
    }
}

export interface IIDCard extends IValueObject {
    nationalIDType?: string;
    nationalIDNo?: string;
}

export class RegionModel implements IRegionModel {
    id?: number;
    name?: string;

    constructor(data?: IRegionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RegionModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRegionModel {
    id?: number;
    name?: string;
}

export class CountryModel implements ICountryModel {
    id?: number;
    name?: string;

    constructor(data?: ICountryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryModel {
    id?: number;
    name?: string;
}

export enum Disability {
    Blind = 0,
    Deaf_One_Ear = 1,
    Deaf_Dump = 2,
    Amputee = 3,
    Normal = 4,
    Crippled = 5,
    Blind_One_Eye = 6,
    Deaf = 7,
}

export class ReligionModel implements IReligionModel {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IReligionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ReligionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReligionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IReligionModel {
    id?: number | undefined;
    name?: string | undefined;
}

export enum Session {
    Regular = 0,
    Evening = 1,
    Sandwich = 2,
    Distance = 3,
}

export enum EntryQualification {
    WASSCE = 0,
    SSCE = 1,
    NVTI = 2,
    DEGREE = 3,
    MASTERS = 4,
    HND = 5,
    DIPLOMA = 6,
    BECE = 7,
    PhD = 8,
}

export class FormerSchoolModel implements IFormerSchoolModel {
    id?: number;
    name?: string;
    location?: string;
    region?: number;

    constructor(data?: IFormerSchoolModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): FormerSchoolModel {
        data = typeof data === 'object' ? data : {};
        let result = new FormerSchoolModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["location"] = this.location;
        data["region"] = this.region;
        return data;
    }
}

export interface IFormerSchoolModel {
    id?: number;
    name?: string;
    location?: string;
    region?: number;
}

export enum AdmissionType {
    Mature = 0,
    Regular = 1,
    Access = 2,
    Conditional = 3,
}

export enum ApplicationStatus {
    Admitted = 0,
    Applicant = 1,
    Reported = 2,
    FeePaid = 3,
}

export class Money extends ValueObject implements IMoney {
    currency?: string;
    amount?: number;

    constructor(data?: IMoney) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.currency = _data["currency"];
            this.amount = _data["amount"];
        }
    }

    static override fromJS(data: any): Money {
        data = typeof data === 'object' ? data : {};
        let result = new Money();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        super.toJSON(data);
        return data;
    }
}

export interface IMoney extends IValueObject {
    currency?: string;
    amount?: number;
}

export class ProgrammeModel implements IProgrammeModel {
    id?: number;
    name?: string;
    code?: string;
    levelAdmitted?: string;
    runing?: boolean;
    showOnPortal?: boolean;
    type?: string;
    duration?: number;
    department?: number;
    applicant?: ApplicantModel[];

    constructor(data?: IProgrammeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.levelAdmitted = _data["levelAdmitted"];
            this.runing = _data["runing"];
            this.showOnPortal = _data["showOnPortal"];
            this.type = _data["type"];
            this.duration = _data["duration"];
            this.department = _data["department"];
            if (Array.isArray(_data["applicant"])) {
                this.applicant = [] as any;
                for (let item of _data["applicant"])
                    this.applicant!.push(ApplicantModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgrammeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProgrammeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["levelAdmitted"] = this.levelAdmitted;
        data["runing"] = this.runing;
        data["showOnPortal"] = this.showOnPortal;
        data["type"] = this.type;
        data["duration"] = this.duration;
        data["department"] = this.department;
        if (Array.isArray(this.applicant)) {
            data["applicant"] = [];
            for (let item of this.applicant)
                data["applicant"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProgrammeModel {
    id?: number;
    name?: string;
    code?: string;
    levelAdmitted?: string;
    runing?: boolean;
    showOnPortal?: boolean;
    type?: string;
    duration?: number;
    department?: number;
    applicant?: ApplicantModel[];
}

export class ResultUploadModel extends BaseEntity implements IResultUploadModel {
    subjectID?: number;
    examType?: string;
    gradeID?: number;
    gradeOld?: number | undefined;
    gradeValueOld?: string | undefined;
    indexNo?: string;
    sitting?: string;
    month?: string;
    form?: number;
    center?: string;
    year?: string;
    oldSubject?: string | undefined;
    institutionName?: string | undefined;
    applicantModelID?: number;
    applicantModel?: ApplicantModel;
    subject?: SubjectModel;
    grade?: GradeModel;

    constructor(data?: IResultUploadModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.subjectID = _data["subjectID"];
            this.examType = _data["examType"];
            this.gradeID = _data["gradeID"];
            this.gradeOld = _data["gradeOld"];
            this.gradeValueOld = _data["gradeValueOld"];
            this.indexNo = _data["indexNo"];
            this.sitting = _data["sitting"];
            this.month = _data["month"];
            this.form = _data["form"];
            this.center = _data["center"];
            this.year = _data["year"];
            this.oldSubject = _data["oldSubject"];
            this.institutionName = _data["institutionName"];
            this.applicantModelID = _data["applicantModelID"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
            this.subject = _data["subject"] ? SubjectModel.fromJS(_data["subject"]) : <any>undefined;
            this.grade = _data["grade"] ? GradeModel.fromJS(_data["grade"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ResultUploadModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultUploadModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectID"] = this.subjectID;
        data["examType"] = this.examType;
        data["gradeID"] = this.gradeID;
        data["gradeOld"] = this.gradeOld;
        data["gradeValueOld"] = this.gradeValueOld;
        data["indexNo"] = this.indexNo;
        data["sitting"] = this.sitting;
        data["month"] = this.month;
        data["form"] = this.form;
        data["center"] = this.center;
        data["year"] = this.year;
        data["oldSubject"] = this.oldSubject;
        data["institutionName"] = this.institutionName;
        data["applicantModelID"] = this.applicantModelID;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IResultUploadModel extends IBaseEntity {
    subjectID?: number;
    examType?: string;
    gradeID?: number;
    gradeOld?: number | undefined;
    gradeValueOld?: string | undefined;
    indexNo?: string;
    sitting?: string;
    month?: string;
    form?: number;
    center?: string;
    year?: string;
    oldSubject?: string | undefined;
    institutionName?: string | undefined;
    applicantModelID?: number;
    applicantModel?: ApplicantModel;
    subject?: SubjectModel;
    grade?: GradeModel;
}

export class SubjectModel implements ISubjectModel {
    id?: number;
    name?: string;
    code?: string;
    type?: string;

    constructor(data?: ISubjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SubjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["type"] = this.type;
        return data;
    }
}

export interface ISubjectModel {
    id?: number;
    name?: string;
    code?: string;
    type?: string;
}

export class GradeModel implements IGradeModel {
    id?: number;
    name?: string;
    value?: number;
    comment?: string;
    exam?: number;

    constructor(data?: IGradeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.comment = _data["comment"];
            this.exam = _data["exam"];
        }
    }

    static fromJS(data: any): GradeModel {
        data = typeof data === 'object' ? data : {};
        let result = new GradeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["comment"] = this.comment;
        data["exam"] = this.exam;
        return data;
    }
}

export interface IGradeModel {
    id?: number;
    name?: string;
    value?: number;
    comment?: string;
    exam?: number;
}

export abstract class BaseEvent implements IBaseEvent {

    constructor(data?: IBaseEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IBaseEvent {
}

export class WorkingExperienceModel extends BaseEntity implements IWorkingExperienceModel {
    id?: number;
    companyName?: string;
    companyPhone?: string;
    companyAddress?: string;
    companyPosition?: string;
    companyFrom?: string;
    companyTo?: string;
    applicantModel?: ApplicantModel | undefined;

    constructor(data?: IWorkingExperienceModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.companyPhone = _data["companyPhone"];
            this.companyAddress = _data["companyAddress"];
            this.companyPosition = _data["companyPosition"];
            this.companyFrom = _data["companyFrom"];
            this.companyTo = _data["companyTo"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): WorkingExperienceModel {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingExperienceModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["companyPhone"] = this.companyPhone;
        data["companyAddress"] = this.companyAddress;
        data["companyPosition"] = this.companyPosition;
        data["companyFrom"] = this.companyFrom;
        data["companyTo"] = this.companyTo;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IWorkingExperienceModel extends IBaseEntity {
    id?: number;
    companyName?: string;
    companyPhone?: string;
    companyAddress?: string;
    companyPosition?: string;
    companyFrom?: string;
    companyTo?: string;
    applicantModel?: ApplicantModel | undefined;
}

export class AcademicExperienceModel extends BaseAuditableEntity implements IAcademicExperienceModel {
    id?: number;
    institutionName?: string;
    institutionAddress?: string;
    programmeStudied?: string;
    from?: Date;
    to?: Date;
    certificate?: string;
    applicantModelID?: number;
    applicantModel?: ApplicantModel | undefined;

    constructor(data?: IAcademicExperienceModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.institutionName = _data["institutionName"];
            this.institutionAddress = _data["institutionAddress"];
            this.programmeStudied = _data["programmeStudied"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            this.certificate = _data["certificate"];
            this.applicantModelID = _data["applicantModelID"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AcademicExperienceModel {
        data = typeof data === 'object' ? data : {};
        let result = new AcademicExperienceModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["institutionName"] = this.institutionName;
        data["institutionAddress"] = this.institutionAddress;
        data["programmeStudied"] = this.programmeStudied;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["certificate"] = this.certificate;
        data["applicantModelID"] = this.applicantModelID;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAcademicExperienceModel extends IBaseAuditableEntity {
    id?: number;
    institutionName?: string;
    institutionAddress?: string;
    programmeStudied?: string;
    from?: Date;
    to?: Date;
    certificate?: string;
    applicantModelID?: number;
    applicantModel?: ApplicantModel | undefined;
}

export class DocumentUploadModel extends BaseAuditableEntity implements IDocumentUploadModel {
    applicant?: number;
    name?: string;
    type?: string;

    constructor(data?: IDocumentUploadModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applicant = _data["applicant"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static override fromJS(data: any): DocumentUploadModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentUploadModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicant"] = this.applicant;
        data["name"] = this.name;
        data["type"] = this.type;
        super.toJSON(data);
        return data;
    }
}

export interface IDocumentUploadModel extends IBaseAuditableEntity {
    applicant?: number;
    name?: string;
    type?: string;
}

export class RefereeModel extends BaseAuditableEntity implements IRefereeModel {
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicantModel?: ApplicantModel;
    refereeStatus?: RefereeStatus;

    constructor(data?: IRefereeModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.institution = _data["institution"];
            this.email = _data["email"];
            this.position = _data["position"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
            this.refereeStatus = _data["refereeStatus"];
        }
    }

    static override fromJS(data: any): RefereeModel {
        data = typeof data === 'object' ? data : {};
        let result = new RefereeModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["institution"] = this.institution;
        data["email"] = this.email;
        data["position"] = this.position;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        data["refereeStatus"] = this.refereeStatus;
        super.toJSON(data);
        return data;
    }
}

export interface IRefereeModel extends IBaseAuditableEntity {
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicantModel?: ApplicantModel;
    refereeStatus?: RefereeStatus;
}

export enum RefereeStatus {
    Approved = 0,
    Pending = 1,
    Declined = 2,
}

export class AddressModel implements IAddressModel {
    id?: number;
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
    applicant?: ApplicantModel;

    constructor(data?: IAddressModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.street = _data["street"];
            this.houseNumber = _data["houseNumber"];
            this.city = _data["city"];
            this.gprs = _data["gprs"];
            this.box = _data["box"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddressModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddressModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["street"] = this.street;
        data["houseNumber"] = this.houseNumber;
        data["city"] = this.city;
        data["gprs"] = this.gprs;
        data["box"] = this.box;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddressModel {
    id?: number;
    street?: string | undefined;
    houseNumber?: string | undefined;
    city?: string | undefined;
    gprs?: string | undefined;
    box?: string | undefined;
    applicant?: ApplicantModel;
}

export class LanguageModel implements ILanguageModel {
    id?: number;
    name?: string | undefined;
    applicantModelID?: number;

    constructor(data?: ILanguageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.applicantModelID = _data["applicantModelID"];
        }
    }

    static fromJS(data: any): LanguageModel {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["applicantModelID"] = this.applicantModelID;
        return data;
    }
}

export interface ILanguageModel {
    id?: number;
    name?: string | undefined;
    applicantModelID?: number;
}

export class SMSModel implements ISMSModel {
    id?: number;
    message?: string;
    sentBy?: string;
    recipient?: number;
    dateSent?: Date;
    status?: string | undefined;
    applicantModelID?: number;

    constructor(data?: ISMSModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.message = _data["message"];
            this.sentBy = _data["sentBy"];
            this.recipient = _data["recipient"];
            this.dateSent = _data["dateSent"] ? new Date(_data["dateSent"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.applicantModelID = _data["applicantModelID"];
        }
    }

    static fromJS(data: any): SMSModel {
        data = typeof data === 'object' ? data : {};
        let result = new SMSModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["message"] = this.message;
        data["sentBy"] = this.sentBy;
        data["recipient"] = this.recipient;
        data["dateSent"] = this.dateSent ? this.dateSent.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["applicantModelID"] = this.applicantModelID;
        return data;
    }
}

export interface ISMSModel {
    id?: number;
    message?: string;
    sentBy?: string;
    recipient?: number;
    dateSent?: Date;
    status?: string | undefined;
    applicantModelID?: number;
}

export class ApplicantIssueModel extends BaseAuditableEntity implements IApplicantIssueModel {
    applicantId?: number;
    applicant?: ApplicantModel;
    issue?: string | undefined;

    constructor(data?: IApplicantIssueModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applicantId = _data["applicantId"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
            this.issue = _data["issue"];
        }
    }

    static override fromJS(data: any): ApplicantIssueModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicantIssueModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicantId"] = this.applicantId;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["issue"] = this.issue;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicantIssueModel extends IBaseAuditableEntity {
    applicantId?: number;
    applicant?: ApplicantModel;
    issue?: string | undefined;
}

export class ResearchModel implements IResearchModel {
    id?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;
    applicant?: ApplicantModel;

    constructor(data?: IResearchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.month = _data["month"];
            this.areaOfResearchIfAdmitted = _data["areaOfResearchIfAdmitted"];
            this.actualAreaOfResearch = _data["actualAreaOfResearch"];
            this.futureResearchInterest = _data["futureResearchInterest"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResearchModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["month"] = this.month;
        data["areaOfResearchIfAdmitted"] = this.areaOfResearchIfAdmitted;
        data["actualAreaOfResearch"] = this.actualAreaOfResearch;
        data["futureResearchInterest"] = this.futureResearchInterest;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResearchModel {
    id?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;
    applicant?: ApplicantModel;
}

export class ResearchPublicationModel implements IResearchPublicationModel {
    id?: number;
    applicant?: ApplicantModel;
    publication?: string | undefined;

    constructor(data?: IResearchPublicationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
            this.publication = _data["publication"];
        }
    }

    static fromJS(data: any): ResearchPublicationModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchPublicationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["publication"] = this.publication;
        return data;
    }
}

export interface IResearchPublicationModel {
    id?: number;
    applicant?: ApplicantModel;
    publication?: string | undefined;
}

export class UniversityAttendedModel implements IUniversityAttendedModel {
    id?: number;
    name?: string | undefined;
    location?: CountryModel | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
    studentNumber?: string | undefined;
    degreeObtained?: string | undefined;
    degreeClassification?: string | undefined;
    cgpa?: number | undefined;
    applicant?: number;
    applicantModel?: ApplicantModel | undefined;

    constructor(data?: IUniversityAttendedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.location = _data["location"] ? CountryModel.fromJS(_data["location"]) : <any>undefined;
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
            this.studentNumber = _data["studentNumber"];
            this.degreeObtained = _data["degreeObtained"];
            this.degreeClassification = _data["degreeClassification"];
            this.cgpa = _data["cgpa"];
            this.applicant = _data["applicant"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UniversityAttendedModel {
        data = typeof data === 'object' ? data : {};
        let result = new UniversityAttendedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        data["studentNumber"] = this.studentNumber;
        data["degreeObtained"] = this.degreeObtained;
        data["degreeClassification"] = this.degreeClassification;
        data["cgpa"] = this.cgpa;
        data["applicant"] = this.applicant;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUniversityAttendedModel {
    id?: number;
    name?: string | undefined;
    location?: CountryModel | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
    studentNumber?: string | undefined;
    degreeObtained?: string | undefined;
    degreeClassification?: string | undefined;
    cgpa?: number | undefined;
    applicant?: number;
    applicantModel?: ApplicantModel | undefined;
}

export class SHSAttendedModel implements ISHSAttendedModel {
    id?: number;
    attendedTTU?: boolean;
    applicant?: number;
    applicantModel?: ApplicantModel | undefined;
    name?: FormerSchoolModel | undefined;
    location?: RegionModel | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;

    constructor(data?: ISHSAttendedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.attendedTTU = _data["attendedTTU"];
            this.applicant = _data["applicant"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
            this.name = _data["name"] ? FormerSchoolModel.fromJS(_data["name"]) : <any>undefined;
            this.location = _data["location"] ? RegionModel.fromJS(_data["location"]) : <any>undefined;
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
        }
    }

    static fromJS(data: any): SHSAttendedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SHSAttendedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attendedTTU"] = this.attendedTTU;
        data["applicant"] = this.applicant;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        return data;
    }
}

export interface ISHSAttendedModel {
    id?: number;
    attendedTTU?: boolean;
    applicant?: number;
    applicantModel?: ApplicantModel | undefined;
    name?: FormerSchoolModel | undefined;
    location?: RegionModel | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
}

export class DisabilitiesModel implements IDisabilitiesModel {
    id?: number;
    name?: string;

    constructor(data?: IDisabilitiesModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DisabilitiesModel {
        data = typeof data === 'object' ? data : {};
        let result = new DisabilitiesModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDisabilitiesModel {
    id?: number;
    name?: string;
}

export class ApplicantVm implements IApplicantVm {
    id?: number;
    applicationNumber?: ApplicationNumber;
    title?: Title;
    applicantName?: ApplicantName;
    previousName?: ApplicantName | undefined;
    dob?: Date;
    gender?: Gender;
    age?: number;
    maritalStatus?: MaritalStatus | undefined;
    noOfChildren?: number | undefined;
    phone?: PhoneNumber;
    altPhone?: PhoneNumber | undefined;
    email?: EmailAddress;
    postGPRS?: string | undefined;
    emergencyContact?: PhoneNumber | undefined;
    hometown?: string | undefined;
    districtId?: number | undefined;
    district?: DistrictModel | undefined;
    hall?: HallModel | undefined;
    idcard?: IDCard | undefined;
    regionId?: number | undefined;
    region?: RegionModel | undefined;
    nationalityId?: number | undefined;
    nationality?: CountryModel | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: PhoneNumber;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability | undefined;
    sourceOfFinance?: string | undefined;
    religionId?: number | undefined;
    religion?: ReligionModel | undefined;
    denomination?: string | undefined;
    referrals?: string | undefined;
    entryMode?: Session | undefined;
    firstQualification?: EntryQualification | undefined;
    secondQualification?: EntryQualification | undefined;
    programmeStudied?: string | undefined;
    formerSchool?: string | undefined;
    formerSchoolNewId?: number | undefined;
    programmeAdmittedId?: number | undefined;
    lastYearInSchool?: number | undefined;
    awaiting?: boolean | undefined;
    grade?: number | undefined;
    preferedHall?: string | undefined;
    elligible?: boolean | undefined;
    admitted?: boolean | undefined;
    admittedBy?: number | undefined;
    admissionType?: string | undefined;
    leveladmitted?: string | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    sponsorShip?: boolean | undefined;
    sponsorShipCompany?: string | undefined;
    sponsorShipLocation?: string | undefined;
    sponsorShipCompanyContact?: string | undefined;
    getFullName?: string;
    programmes?: ProgrammeModel[];
    resultUploads?: ResultUploadModel[];
    workingExperiences?: (WorkingExperienceModel | undefined)[];
    academicExperiences?: (AcademicExperienceModel | undefined)[];
    documents?: (DocumentUploadModel | undefined)[];
    referees?: (RefereeModel | undefined)[];
    addresses?: (AddressModel | undefined)[];
    languages?: (LanguageModel | undefined)[];
    sms?: SMSModel[];
    researchModels?: ResearchModel[] | undefined;
    researchPublications?: ResearchPublicationModel[] | undefined;
    universityAttended?: UniversityAttendedModel[] | undefined;
    shsAttend?: SHSAttendedModel[] | undefined;
    disabilities?: DisabilitiesModel[] | undefined;

    constructor(data?: IApplicantVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicationNumber = _data["applicationNumber"] ? ApplicationNumber.fromJS(_data["applicationNumber"]) : <any>undefined;
            this.title = _data["title"];
            this.applicantName = _data["applicantName"] ? ApplicantName.fromJS(_data["applicantName"]) : <any>undefined;
            this.previousName = _data["previousName"] ? ApplicantName.fromJS(_data["previousName"]) : <any>undefined;
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.age = _data["age"];
            this.maritalStatus = _data["maritalStatus"];
            this.noOfChildren = _data["noOfChildren"];
            this.phone = _data["phone"] ? PhoneNumber.fromJS(_data["phone"]) : <any>undefined;
            this.altPhone = _data["altPhone"] ? PhoneNumber.fromJS(_data["altPhone"]) : <any>undefined;
            this.email = _data["email"] ? EmailAddress.fromJS(_data["email"]) : <any>undefined;
            this.postGPRS = _data["postGPRS"];
            this.emergencyContact = _data["emergencyContact"] ? PhoneNumber.fromJS(_data["emergencyContact"]) : <any>undefined;
            this.hometown = _data["hometown"];
            this.districtId = _data["districtId"];
            this.district = _data["district"] ? DistrictModel.fromJS(_data["district"]) : <any>undefined;
            this.hall = _data["hall"] ? HallModel.fromJS(_data["hall"]) : <any>undefined;
            this.idcard = _data["idcard"] ? IDCard.fromJS(_data["idcard"]) : <any>undefined;
            this.regionId = _data["regionId"];
            this.region = _data["region"] ? RegionModel.fromJS(_data["region"]) : <any>undefined;
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? CountryModel.fromJS(_data["nationality"]) : <any>undefined;
            this.residentialStatus = _data["residentialStatus"];
            this.guardianName = _data["guardianName"];
            this.guardianPhone = _data["guardianPhone"] ? PhoneNumber.fromJS(_data["guardianPhone"]) : <any>undefined;
            this.guardianOccupation = _data["guardianOccupation"];
            this.guardianRelationship = _data["guardianRelationship"];
            this.disability = _data["disability"];
            this.disabilityType = _data["disabilityType"];
            this.sourceOfFinance = _data["sourceOfFinance"];
            this.religionId = _data["religionId"];
            this.religion = _data["religion"] ? ReligionModel.fromJS(_data["religion"]) : <any>undefined;
            this.denomination = _data["denomination"];
            this.referrals = _data["referrals"];
            this.entryMode = _data["entryMode"];
            this.firstQualification = _data["firstQualification"];
            this.secondQualification = _data["secondQualification"];
            this.programmeStudied = _data["programmeStudied"];
            this.formerSchool = _data["formerSchool"];
            this.formerSchoolNewId = _data["formerSchoolNewId"];
            this.programmeAdmittedId = _data["programmeAdmittedId"];
            this.lastYearInSchool = _data["lastYearInSchool"];
            this.awaiting = _data["awaiting"];
            this.grade = _data["grade"];
            this.preferedHall = _data["preferedHall"];
            this.elligible = _data["elligible"];
            this.admitted = _data["admitted"];
            this.admittedBy = _data["admittedBy"];
            this.admissionType = _data["admissionType"];
            this.leveladmitted = _data["leveladmitted"];
            this.firstChoiceId = _data["firstChoiceId"];
            this.secondChoiceId = _data["secondChoiceId"];
            this.thirdChoiceId = _data["thirdChoiceId"];
            this.sponsorShip = _data["sponsorShip"];
            this.sponsorShipCompany = _data["sponsorShipCompany"];
            this.sponsorShipLocation = _data["sponsorShipLocation"];
            this.sponsorShipCompanyContact = _data["sponsorShipCompanyContact"];
            this.getFullName = _data["getFullName"];
            if (Array.isArray(_data["programmes"])) {
                this.programmes = [] as any;
                for (let item of _data["programmes"])
                    this.programmes!.push(ProgrammeModel.fromJS(item));
            }
            if (Array.isArray(_data["resultUploads"])) {
                this.resultUploads = [] as any;
                for (let item of _data["resultUploads"])
                    this.resultUploads!.push(ResultUploadModel.fromJS(item));
            }
            if (Array.isArray(_data["workingExperiences"])) {
                this.workingExperiences = [] as any;
                for (let item of _data["workingExperiences"])
                    this.workingExperiences!.push(WorkingExperienceModel.fromJS(item));
            }
            if (Array.isArray(_data["academicExperiences"])) {
                this.academicExperiences = [] as any;
                for (let item of _data["academicExperiences"])
                    this.academicExperiences!.push(AcademicExperienceModel.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentUploadModel.fromJS(item));
            }
            if (Array.isArray(_data["referees"])) {
                this.referees = [] as any;
                for (let item of _data["referees"])
                    this.referees!.push(RefereeModel.fromJS(item));
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(AddressModel.fromJS(item));
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageModel.fromJS(item));
            }
            if (Array.isArray(_data["sms"])) {
                this.sms = [] as any;
                for (let item of _data["sms"])
                    this.sms!.push(SMSModel.fromJS(item));
            }
            if (Array.isArray(_data["researchModels"])) {
                this.researchModels = [] as any;
                for (let item of _data["researchModels"])
                    this.researchModels!.push(ResearchModel.fromJS(item));
            }
            if (Array.isArray(_data["researchPublications"])) {
                this.researchPublications = [] as any;
                for (let item of _data["researchPublications"])
                    this.researchPublications!.push(ResearchPublicationModel.fromJS(item));
            }
            if (Array.isArray(_data["universityAttended"])) {
                this.universityAttended = [] as any;
                for (let item of _data["universityAttended"])
                    this.universityAttended!.push(UniversityAttendedModel.fromJS(item));
            }
            if (Array.isArray(_data["shsAttend"])) {
                this.shsAttend = [] as any;
                for (let item of _data["shsAttend"])
                    this.shsAttend!.push(SHSAttendedModel.fromJS(item));
            }
            if (Array.isArray(_data["disabilities"])) {
                this.disabilities = [] as any;
                for (let item of _data["disabilities"])
                    this.disabilities!.push(DisabilitiesModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicantVm {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicantVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicationNumber"] = this.applicationNumber ? this.applicationNumber.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["applicantName"] = this.applicantName ? this.applicantName.toJSON() : <any>undefined;
        data["previousName"] = this.previousName ? this.previousName.toJSON() : <any>undefined;
        data["dob"] = this.dob ? formatDate(this.dob) : <any>undefined;
        data["gender"] = this.gender;
        data["age"] = this.age;
        data["maritalStatus"] = this.maritalStatus;
        data["noOfChildren"] = this.noOfChildren;
        data["phone"] = this.phone ? this.phone.toJSON() : <any>undefined;
        data["altPhone"] = this.altPhone ? this.altPhone.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["postGPRS"] = this.postGPRS;
        data["emergencyContact"] = this.emergencyContact ? this.emergencyContact.toJSON() : <any>undefined;
        data["hometown"] = this.hometown;
        data["districtId"] = this.districtId;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["hall"] = this.hall ? this.hall.toJSON() : <any>undefined;
        data["idcard"] = this.idcard ? this.idcard.toJSON() : <any>undefined;
        data["regionId"] = this.regionId;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["residentialStatus"] = this.residentialStatus;
        data["guardianName"] = this.guardianName;
        data["guardianPhone"] = this.guardianPhone ? this.guardianPhone.toJSON() : <any>undefined;
        data["guardianOccupation"] = this.guardianOccupation;
        data["guardianRelationship"] = this.guardianRelationship;
        data["disability"] = this.disability;
        data["disabilityType"] = this.disabilityType;
        data["sourceOfFinance"] = this.sourceOfFinance;
        data["religionId"] = this.religionId;
        data["religion"] = this.religion ? this.religion.toJSON() : <any>undefined;
        data["denomination"] = this.denomination;
        data["referrals"] = this.referrals;
        data["entryMode"] = this.entryMode;
        data["firstQualification"] = this.firstQualification;
        data["secondQualification"] = this.secondQualification;
        data["programmeStudied"] = this.programmeStudied;
        data["formerSchool"] = this.formerSchool;
        data["formerSchoolNewId"] = this.formerSchoolNewId;
        data["programmeAdmittedId"] = this.programmeAdmittedId;
        data["lastYearInSchool"] = this.lastYearInSchool;
        data["awaiting"] = this.awaiting;
        data["grade"] = this.grade;
        data["preferedHall"] = this.preferedHall;
        data["elligible"] = this.elligible;
        data["admitted"] = this.admitted;
        data["admittedBy"] = this.admittedBy;
        data["admissionType"] = this.admissionType;
        data["leveladmitted"] = this.leveladmitted;
        data["firstChoiceId"] = this.firstChoiceId;
        data["secondChoiceId"] = this.secondChoiceId;
        data["thirdChoiceId"] = this.thirdChoiceId;
        data["sponsorShip"] = this.sponsorShip;
        data["sponsorShipCompany"] = this.sponsorShipCompany;
        data["sponsorShipLocation"] = this.sponsorShipLocation;
        data["sponsorShipCompanyContact"] = this.sponsorShipCompanyContact;
        data["getFullName"] = this.getFullName;
        if (Array.isArray(this.programmes)) {
            data["programmes"] = [];
            for (let item of this.programmes)
                data["programmes"].push(item.toJSON());
        }
        if (Array.isArray(this.resultUploads)) {
            data["resultUploads"] = [];
            for (let item of this.resultUploads)
                data["resultUploads"].push(item.toJSON());
        }
        if (Array.isArray(this.workingExperiences)) {
            data["workingExperiences"] = [];
            for (let item of this.workingExperiences)
                data["workingExperiences"].push(item.toJSON());
        }
        if (Array.isArray(this.academicExperiences)) {
            data["academicExperiences"] = [];
            for (let item of this.academicExperiences)
                data["academicExperiences"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.referees)) {
            data["referees"] = [];
            for (let item of this.referees)
                data["referees"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.sms)) {
            data["sms"] = [];
            for (let item of this.sms)
                data["sms"].push(item.toJSON());
        }
        if (Array.isArray(this.researchModels)) {
            data["researchModels"] = [];
            for (let item of this.researchModels)
                data["researchModels"].push(item.toJSON());
        }
        if (Array.isArray(this.researchPublications)) {
            data["researchPublications"] = [];
            for (let item of this.researchPublications)
                data["researchPublications"].push(item.toJSON());
        }
        if (Array.isArray(this.universityAttended)) {
            data["universityAttended"] = [];
            for (let item of this.universityAttended)
                data["universityAttended"].push(item.toJSON());
        }
        if (Array.isArray(this.shsAttend)) {
            data["shsAttend"] = [];
            for (let item of this.shsAttend)
                data["shsAttend"].push(item.toJSON());
        }
        if (Array.isArray(this.disabilities)) {
            data["disabilities"] = [];
            for (let item of this.disabilities)
                data["disabilities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApplicantVm {
    id?: number;
    applicationNumber?: ApplicationNumber;
    title?: Title;
    applicantName?: ApplicantName;
    previousName?: ApplicantName | undefined;
    dob?: Date;
    gender?: Gender;
    age?: number;
    maritalStatus?: MaritalStatus | undefined;
    noOfChildren?: number | undefined;
    phone?: PhoneNumber;
    altPhone?: PhoneNumber | undefined;
    email?: EmailAddress;
    postGPRS?: string | undefined;
    emergencyContact?: PhoneNumber | undefined;
    hometown?: string | undefined;
    districtId?: number | undefined;
    district?: DistrictModel | undefined;
    hall?: HallModel | undefined;
    idcard?: IDCard | undefined;
    regionId?: number | undefined;
    region?: RegionModel | undefined;
    nationalityId?: number | undefined;
    nationality?: CountryModel | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: PhoneNumber;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability | undefined;
    sourceOfFinance?: string | undefined;
    religionId?: number | undefined;
    religion?: ReligionModel | undefined;
    denomination?: string | undefined;
    referrals?: string | undefined;
    entryMode?: Session | undefined;
    firstQualification?: EntryQualification | undefined;
    secondQualification?: EntryQualification | undefined;
    programmeStudied?: string | undefined;
    formerSchool?: string | undefined;
    formerSchoolNewId?: number | undefined;
    programmeAdmittedId?: number | undefined;
    lastYearInSchool?: number | undefined;
    awaiting?: boolean | undefined;
    grade?: number | undefined;
    preferedHall?: string | undefined;
    elligible?: boolean | undefined;
    admitted?: boolean | undefined;
    admittedBy?: number | undefined;
    admissionType?: string | undefined;
    leveladmitted?: string | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    sponsorShip?: boolean | undefined;
    sponsorShipCompany?: string | undefined;
    sponsorShipLocation?: string | undefined;
    sponsorShipCompanyContact?: string | undefined;
    getFullName?: string;
    programmes?: ProgrammeModel[];
    resultUploads?: ResultUploadModel[];
    workingExperiences?: (WorkingExperienceModel | undefined)[];
    academicExperiences?: (AcademicExperienceModel | undefined)[];
    documents?: (DocumentUploadModel | undefined)[];
    referees?: (RefereeModel | undefined)[];
    addresses?: (AddressModel | undefined)[];
    languages?: (LanguageModel | undefined)[];
    sms?: SMSModel[];
    researchModels?: ResearchModel[] | undefined;
    researchPublications?: ResearchPublicationModel[] | undefined;
    universityAttended?: UniversityAttendedModel[] | undefined;
    shsAttend?: SHSAttendedModel[] | undefined;
    disabilities?: DisabilitiesModel[] | undefined;
}

export enum ApplicationType {
    CERTIFICATE = 0,
    DIPLOMA = 1,
    HND = 2,
    BTECH = 3,
    TOPUP_DIPLOMA = 4,
    TOPUP_CERTIFICATE = 5,
    MTECH = 6,
    PhD = 7,
}

export class CreateFormUpdateRequest implements ICreateFormUpdateRequest {
    formType?: ApplicationType;

    constructor(data?: ICreateFormUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formType = _data["formType"];
        }
    }

    static fromJS(data: any): CreateFormUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFormUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formType"] = this.formType;
        return data;
    }
}

export interface ICreateFormUpdateRequest {
    formType?: ApplicationType;
}

export class CreateBiodataRequest implements ICreateBiodataRequest {
    id?: number | undefined;
    applicationNumber?: number;
    firstName?: string;
    lastName?: string;
    otherName?: string | undefined;
    previousName?: string | undefined;
    noOfChildren?: number | undefined;
    gender?: Gender;
    dob?: Date;
    month?: string | undefined;
    year?: string | undefined;
    day?: string | undefined;
    title?: Title;
    maritalStatus?: MaritalStatus | undefined;
    phone?: string;
    altPhone?: string | undefined;
    email?: string | undefined;
    postGPRS?: string | undefined;
    emergencyContact?: string | undefined;
    hometown?: string | undefined;
    district?: number | undefined;
    nationalIDNo?: string | undefined;
    nationalIDType?: IDCards | undefined;
    regionId?: number | undefined;
    nationalityId?: number | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: string | undefined;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability | undefined;
    sourceOfFinance?: string | undefined;
    religionId?: number | undefined;
    denomination?: string | undefined;
    idCard?: IDCard | undefined;
    referrals?: string | undefined;
    admitted?: boolean | undefined;
    leveladmitted?: string | undefined;
    grade?: number | undefined;
    admittedBy?: number | undefined;
    sponsorShip?: boolean | undefined;
    sponsorShipCompany?: string | undefined;
    sponsorShipLocation?: string | undefined;
    sponsorShipCompanyContact?: string | undefined;

    constructor(data?: ICreateBiodataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicationNumber = _data["applicationNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.otherName = _data["otherName"];
            this.previousName = _data["previousName"];
            this.noOfChildren = _data["noOfChildren"];
            this.gender = _data["gender"];
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.month = _data["month"];
            this.year = _data["year"];
            this.day = _data["day"];
            this.title = _data["title"];
            this.maritalStatus = _data["maritalStatus"];
            this.phone = _data["phone"];
            this.altPhone = _data["altPhone"];
            this.email = _data["email"];
            this.postGPRS = _data["postGPRS"];
            this.emergencyContact = _data["emergencyContact"];
            this.hometown = _data["hometown"];
            this.district = _data["district"];
            this.nationalIDNo = _data["nationalIDNo"];
            this.nationalIDType = _data["nationalIDType"];
            this.regionId = _data["regionId"];
            this.nationalityId = _data["nationalityId"];
            this.residentialStatus = _data["residentialStatus"];
            this.guardianName = _data["guardianName"];
            this.guardianPhone = _data["guardianPhone"];
            this.guardianOccupation = _data["guardianOccupation"];
            this.guardianRelationship = _data["guardianRelationship"];
            this.disability = _data["disability"];
            this.disabilityType = _data["disabilityType"];
            this.sourceOfFinance = _data["sourceOfFinance"];
            this.religionId = _data["religionId"];
            this.denomination = _data["denomination"];
            this.idCard = _data["idCard"] ? IDCard.fromJS(_data["idCard"]) : <any>undefined;
            this.referrals = _data["referrals"];
            this.admitted = _data["admitted"];
            this.leveladmitted = _data["leveladmitted"];
            this.grade = _data["grade"];
            this.admittedBy = _data["admittedBy"];
            this.sponsorShip = _data["sponsorShip"];
            this.sponsorShipCompany = _data["sponsorShipCompany"];
            this.sponsorShipLocation = _data["sponsorShipLocation"];
            this.sponsorShipCompanyContact = _data["sponsorShipCompanyContact"];
        }
    }

    static fromJS(data: any): CreateBiodataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBiodataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicationNumber"] = this.applicationNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["otherName"] = this.otherName;
        data["previousName"] = this.previousName;
        data["noOfChildren"] = this.noOfChildren;
        data["gender"] = this.gender;
        data["dob"] = this.dob ? formatDate(this.dob) : <any>undefined;
        data["month"] = this.month;
        data["year"] = this.year;
        data["day"] = this.day;
        data["title"] = this.title;
        data["maritalStatus"] = this.maritalStatus;
        data["phone"] = this.phone;
        data["altPhone"] = this.altPhone;
        data["email"] = this.email;
        data["postGPRS"] = this.postGPRS;
        data["emergencyContact"] = this.emergencyContact;
        data["hometown"] = this.hometown;
        data["district"] = this.district;
        data["nationalIDNo"] = this.nationalIDNo;
        data["nationalIDType"] = this.nationalIDType;
        data["regionId"] = this.regionId;
        data["nationalityId"] = this.nationalityId;
        data["residentialStatus"] = this.residentialStatus;
        data["guardianName"] = this.guardianName;
        data["guardianPhone"] = this.guardianPhone;
        data["guardianOccupation"] = this.guardianOccupation;
        data["guardianRelationship"] = this.guardianRelationship;
        data["disability"] = this.disability;
        data["disabilityType"] = this.disabilityType;
        data["sourceOfFinance"] = this.sourceOfFinance;
        data["religionId"] = this.religionId;
        data["denomination"] = this.denomination;
        data["idCard"] = this.idCard ? this.idCard.toJSON() : <any>undefined;
        data["referrals"] = this.referrals;
        data["admitted"] = this.admitted;
        data["leveladmitted"] = this.leveladmitted;
        data["grade"] = this.grade;
        data["admittedBy"] = this.admittedBy;
        data["sponsorShip"] = this.sponsorShip;
        data["sponsorShipCompany"] = this.sponsorShipCompany;
        data["sponsorShipLocation"] = this.sponsorShipLocation;
        data["sponsorShipCompanyContact"] = this.sponsorShipCompanyContact;
        return data;
    }
}

export interface ICreateBiodataRequest {
    id?: number | undefined;
    applicationNumber?: number;
    firstName?: string;
    lastName?: string;
    otherName?: string | undefined;
    previousName?: string | undefined;
    noOfChildren?: number | undefined;
    gender?: Gender;
    dob?: Date;
    month?: string | undefined;
    year?: string | undefined;
    day?: string | undefined;
    title?: Title;
    maritalStatus?: MaritalStatus | undefined;
    phone?: string;
    altPhone?: string | undefined;
    email?: string | undefined;
    postGPRS?: string | undefined;
    emergencyContact?: string | undefined;
    hometown?: string | undefined;
    district?: number | undefined;
    nationalIDNo?: string | undefined;
    nationalIDType?: IDCards | undefined;
    regionId?: number | undefined;
    nationalityId?: number | undefined;
    residentialStatus?: boolean | undefined;
    guardianName?: string | undefined;
    guardianPhone?: string | undefined;
    guardianOccupation?: string | undefined;
    guardianRelationship?: string | undefined;
    disability?: boolean | undefined;
    disabilityType?: Disability | undefined;
    sourceOfFinance?: string | undefined;
    religionId?: number | undefined;
    denomination?: string | undefined;
    idCard?: IDCard | undefined;
    referrals?: string | undefined;
    admitted?: boolean | undefined;
    leveladmitted?: string | undefined;
    grade?: number | undefined;
    admittedBy?: number | undefined;
    sponsorShip?: boolean | undefined;
    sponsorShipCompany?: string | undefined;
    sponsorShipLocation?: string | undefined;
    sponsorShipCompanyContact?: string | undefined;
}

export enum IDCards {
    GhanaCard = 0,
    VotersCard = 1,
    NHIS = 2,
    PassPort = 3,
    DriversLicense = 4,
    Other = 5,
}

export class UploadDocumentRequest implements IUploadDocumentRequest {
    userId?: string | undefined;
    id?: number;
    applicant?: number;
    name?: string | undefined;
    type?: string | undefined;
    files?: FileDto[];

    constructor(data?: IUploadDocumentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.name = _data["name"];
            this.type = _data["type"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(FileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadDocumentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDocumentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["name"] = this.name;
        data["type"] = this.type;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUploadDocumentRequest {
    userId?: string | undefined;
    id?: number;
    applicant?: number;
    name?: string | undefined;
    type?: string | undefined;
    files?: FileDto[];
}

export class FileDto implements IFileDto {
    content?: Stream;
    name?: string;
    userId?: string | undefined;
    contentType?: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"] ? Stream.fromJS(_data["content"]) : <any>undefined;
            this.name = _data["name"];
            this.userId = _data["userId"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["userId"] = this.userId;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IFileDto {
    content?: Stream;
    name?: string;
    userId?: string | undefined;
    contentType?: string;
}

export abstract class MarshalByRefObject implements IMarshalByRefObject {

    constructor(data?: IMarshalByRefObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): MarshalByRefObject {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MarshalByRefObject' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IMarshalByRefObject {
}

export abstract class Stream extends MarshalByRefObject implements IStream {
    canTimeout?: boolean;
    readTimeout?: number;
    writeTimeout?: number;

    constructor(data?: IStream) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.canTimeout = _data["canTimeout"];
            this.readTimeout = _data["readTimeout"];
            this.writeTimeout = _data["writeTimeout"];
        }
    }

    static override fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Stream' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canTimeout"] = this.canTimeout;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        super.toJSON(data);
        return data;
    }
}

export interface IStream extends IMarshalByRefObject {
    canTimeout?: boolean;
    readTimeout?: number;
    writeTimeout?: number;
}

export class PaginatedListOfDocumentUploadDto implements IPaginatedListOfDocumentUploadDto {
    items?: DocumentUploadDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfDocumentUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DocumentUploadDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfDocumentUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfDocumentUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfDocumentUploadDto {
    items?: DocumentUploadDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class DocumentUploadDto implements IDocumentUploadDto {
    id?: number;
    applicant?: number;
    name?: string | undefined;
    type?: string | undefined;

    constructor(data?: IDocumentUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): DocumentUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export interface IDocumentUploadDto {
    id?: number;
    applicant?: number;
    name?: string | undefined;
    type?: string | undefined;
}

export class PaginatedListOfSHSAttendedDto implements IPaginatedListOfSHSAttendedDto {
    items?: SHSAttendedDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfSHSAttendedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SHSAttendedDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfSHSAttendedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSHSAttendedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfSHSAttendedDto {
    items?: SHSAttendedDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SHSAttendedDto implements ISHSAttendedDto {
    id?: number;
    attendedTTU?: boolean;
    applicant?: ApplicantModel | undefined;
    name?: FormerSchoolModel | undefined;
    location?: RegionModel | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;

    constructor(data?: ISHSAttendedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.attendedTTU = _data["attendedTTU"];
            this.applicant = _data["applicant"] ? ApplicantModel.fromJS(_data["applicant"]) : <any>undefined;
            this.name = _data["name"] ? FormerSchoolModel.fromJS(_data["name"]) : <any>undefined;
            this.location = _data["location"] ? RegionModel.fromJS(_data["location"]) : <any>undefined;
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
        }
    }

    static fromJS(data: any): SHSAttendedDto {
        data = typeof data === 'object' ? data : {};
        let result = new SHSAttendedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attendedTTU"] = this.attendedTTU;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        return data;
    }
}

export interface ISHSAttendedDto {
    id?: number;
    attendedTTU?: boolean;
    applicant?: ApplicantModel | undefined;
    name?: FormerSchoolModel | undefined;
    location?: RegionModel | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
}

export class SHSAttendedRequest implements ISHSAttendedRequest {
    id?: number;
    attendedTTU?: boolean;
    name?: string | undefined;
    programmeStudied?: string | undefined;
    location?: number | undefined;
    applicant?: number | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;

    constructor(data?: ISHSAttendedRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.attendedTTU = _data["attendedTTU"];
            this.name = _data["name"];
            this.programmeStudied = _data["programmeStudied"];
            this.location = _data["location"];
            this.applicant = _data["applicant"];
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
        }
    }

    static fromJS(data: any): SHSAttendedRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SHSAttendedRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attendedTTU"] = this.attendedTTU;
        data["name"] = this.name;
        data["programmeStudied"] = this.programmeStudied;
        data["location"] = this.location;
        data["applicant"] = this.applicant;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        return data;
    }
}

export interface ISHSAttendedRequest {
    id?: number;
    attendedTTU?: boolean;
    name?: string | undefined;
    programmeStudied?: string | undefined;
    location?: number | undefined;
    applicant?: number | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
}

export class PaginatedListOfUniversityAttendedDto implements IPaginatedListOfUniversityAttendedDto {
    items?: UniversityAttendedDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfUniversityAttendedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UniversityAttendedDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfUniversityAttendedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfUniversityAttendedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfUniversityAttendedDto {
    items?: UniversityAttendedDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class UniversityAttendedDto implements IUniversityAttendedDto {
    id?: number;
    applicant?: number;
    name?: string | undefined;
    country?: string | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
    studentNumber?: string | undefined;
    degreeObtained?: string | undefined;
    degreeClassification?: string | undefined;
    cgpa?: number | undefined;

    constructor(data?: IUniversityAttendedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.name = _data["name"];
            this.country = _data["country"];
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
            this.studentNumber = _data["studentNumber"];
            this.degreeObtained = _data["degreeObtained"];
            this.degreeClassification = _data["degreeClassification"];
            this.cgpa = _data["cgpa"];
        }
    }

    static fromJS(data: any): UniversityAttendedDto {
        data = typeof data === 'object' ? data : {};
        let result = new UniversityAttendedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["name"] = this.name;
        data["country"] = this.country;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        data["studentNumber"] = this.studentNumber;
        data["degreeObtained"] = this.degreeObtained;
        data["degreeClassification"] = this.degreeClassification;
        data["cgpa"] = this.cgpa;
        return data;
    }
}

export interface IUniversityAttendedDto {
    id?: number;
    applicant?: number;
    name?: string | undefined;
    country?: string | undefined;
    startYear?: string | undefined;
    endYear?: string | undefined;
    studentNumber?: string | undefined;
    degreeObtained?: string | undefined;
    degreeClassification?: string | undefined;
    cgpa?: number | undefined;
}

export class UniversityAttendedRequest implements IUniversityAttendedRequest {
    id?: number | undefined;
    name?: string | undefined;
    country?: number;
    startYear?: string | undefined;
    endYear?: string | undefined;
    studentNumber?: string | undefined;
    degreeObtained?: string | undefined;
    degreeClassification?: string | undefined;
    cgpa?: number | undefined;
    applicant?: number | undefined;

    constructor(data?: IUniversityAttendedRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.country = _data["country"];
            this.startYear = _data["startYear"];
            this.endYear = _data["endYear"];
            this.studentNumber = _data["studentNumber"];
            this.degreeObtained = _data["degreeObtained"];
            this.degreeClassification = _data["degreeClassification"];
            this.cgpa = _data["cgpa"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): UniversityAttendedRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UniversityAttendedRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["country"] = this.country;
        data["startYear"] = this.startYear;
        data["endYear"] = this.endYear;
        data["studentNumber"] = this.studentNumber;
        data["degreeObtained"] = this.degreeObtained;
        data["degreeClassification"] = this.degreeClassification;
        data["cgpa"] = this.cgpa;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface IUniversityAttendedRequest {
    id?: number | undefined;
    name?: string | undefined;
    country?: number;
    startYear?: string | undefined;
    endYear?: string | undefined;
    studentNumber?: string | undefined;
    degreeObtained?: string | undefined;
    degreeClassification?: string | undefined;
    cgpa?: number | undefined;
    applicant?: number | undefined;
}

export class UserDto implements IUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    formNo?: string | undefined;
    started?: number | undefined;
    fullName?: string | undefined;
    type?: string | undefined;
    soldBy?: string | undefined;
    branch?: string | undefined;
    category?: string | undefined;
    formCompleted?: number | undefined;
    pictureUploaded?: number | undefined;
    finalized?: number | undefined;
    year?: string | undefined;
    resultUploaded?: boolean | undefined;
    admitted?: boolean | undefined;
    foriegn?: boolean | undefined;
    lastLogin?: Date | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.formNo = _data["formNo"];
            this.started = _data["started"];
            this.fullName = _data["fullName"];
            this.type = _data["type"];
            this.soldBy = _data["soldBy"];
            this.branch = _data["branch"];
            this.category = _data["category"];
            this.formCompleted = _data["formCompleted"];
            this.pictureUploaded = _data["pictureUploaded"];
            this.finalized = _data["finalized"];
            this.year = _data["year"];
            this.resultUploaded = _data["resultUploaded"];
            this.admitted = _data["admitted"];
            this.foriegn = _data["foriegn"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["formNo"] = this.formNo;
        data["started"] = this.started;
        data["fullName"] = this.fullName;
        data["type"] = this.type;
        data["soldBy"] = this.soldBy;
        data["branch"] = this.branch;
        data["category"] = this.category;
        data["formCompleted"] = this.formCompleted;
        data["pictureUploaded"] = this.pictureUploaded;
        data["finalized"] = this.finalized;
        data["year"] = this.year;
        data["resultUploaded"] = this.resultUploaded;
        data["admitted"] = this.admitted;
        data["foriegn"] = this.foriegn;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    formNo?: string | undefined;
    started?: number | undefined;
    fullName?: string | undefined;
    type?: string | undefined;
    soldBy?: string | undefined;
    branch?: string | undefined;
    category?: string | undefined;
    formCompleted?: number | undefined;
    pictureUploaded?: number | undefined;
    finalized?: number | undefined;
    year?: string | undefined;
    resultUploaded?: boolean | undefined;
    admitted?: boolean | undefined;
    foriegn?: boolean | undefined;
    lastLogin?: Date | undefined;
}

export class ProgressDto implements IProgressDto {
    applicationUserId?: string;
    biodata?: boolean | undefined;
    results?: boolean;
    picture?: boolean;
    age?: boolean;
    formCompletion?: boolean;
    qualification?: boolean;
    documentUpload?: boolean | undefined;
    workingExperience?: boolean | undefined;
    academicExperience?: boolean | undefined;
    researchInformation?: boolean | undefined;
    researchPublication?: boolean | undefined;
    referee?: boolean | undefined;

    constructor(data?: IProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationUserId = _data["applicationUserId"];
            this.biodata = _data["biodata"];
            this.results = _data["results"];
            this.picture = _data["picture"];
            this.age = _data["age"];
            this.formCompletion = _data["formCompletion"];
            this.qualification = _data["qualification"];
            this.documentUpload = _data["documentUpload"];
            this.workingExperience = _data["workingExperience"];
            this.academicExperience = _data["academicExperience"];
            this.researchInformation = _data["researchInformation"];
            this.researchPublication = _data["researchPublication"];
            this.referee = _data["referee"];
        }
    }

    static fromJS(data: any): ProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationUserId"] = this.applicationUserId;
        data["biodata"] = this.biodata;
        data["results"] = this.results;
        data["picture"] = this.picture;
        data["age"] = this.age;
        data["formCompletion"] = this.formCompletion;
        data["qualification"] = this.qualification;
        data["documentUpload"] = this.documentUpload;
        data["workingExperience"] = this.workingExperience;
        data["academicExperience"] = this.academicExperience;
        data["researchInformation"] = this.researchInformation;
        data["researchPublication"] = this.researchPublication;
        data["referee"] = this.referee;
        return data;
    }
}

export interface IProgressDto {
    applicationUserId?: string;
    biodata?: boolean | undefined;
    results?: boolean;
    picture?: boolean;
    age?: boolean;
    formCompletion?: boolean;
    qualification?: boolean;
    documentUpload?: boolean | undefined;
    workingExperience?: boolean | undefined;
    academicExperience?: boolean | undefined;
    researchInformation?: boolean | undefined;
    researchPublication?: boolean | undefined;
    referee?: boolean | undefined;
}

export class ProgrammeInfoRequest implements IProgrammeInfoRequest {
    id?: number | undefined;
    entryMode?: Session | undefined;
    firstQualification?: EntryQualification | undefined;
    secondQualification?: EntryQualification | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    awaiting?: boolean | undefined;
    lastYearInSchool?: number | undefined;

    constructor(data?: IProgrammeInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entryMode = _data["entryMode"];
            this.firstQualification = _data["firstQualification"];
            this.secondQualification = _data["secondQualification"];
            this.firstChoiceId = _data["firstChoiceId"];
            this.secondChoiceId = _data["secondChoiceId"];
            this.thirdChoiceId = _data["thirdChoiceId"];
            this.awaiting = _data["awaiting"];
            this.lastYearInSchool = _data["lastYearInSchool"];
        }
    }

    static fromJS(data: any): ProgrammeInfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProgrammeInfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entryMode"] = this.entryMode;
        data["firstQualification"] = this.firstQualification;
        data["secondQualification"] = this.secondQualification;
        data["firstChoiceId"] = this.firstChoiceId;
        data["secondChoiceId"] = this.secondChoiceId;
        data["thirdChoiceId"] = this.thirdChoiceId;
        data["awaiting"] = this.awaiting;
        data["lastYearInSchool"] = this.lastYearInSchool;
        return data;
    }
}

export interface IProgrammeInfoRequest {
    id?: number | undefined;
    entryMode?: Session | undefined;
    firstQualification?: EntryQualification | undefined;
    secondQualification?: EntryQualification | undefined;
    firstChoiceId?: number | undefined;
    secondChoiceId?: number | undefined;
    thirdChoiceId?: number | undefined;
    awaiting?: boolean | undefined;
    lastYearInSchool?: number | undefined;
}

export class PaginatedListOfRefereeDto implements IPaginatedListOfRefereeDto {
    items?: RefereeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfRefereeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RefereeDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfRefereeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfRefereeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfRefereeDto {
    items?: RefereeDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class RefereeDto implements IRefereeDto {
    id?: number | undefined;
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicant?: number | undefined;

    constructor(data?: IRefereeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.institution = _data["institution"];
            this.email = _data["email"];
            this.position = _data["position"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): RefereeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefereeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["institution"] = this.institution;
        data["email"] = this.email;
        data["position"] = this.position;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface IRefereeDto {
    id?: number | undefined;
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicant?: number | undefined;
}

export class CreateRefereeRequest implements ICreateRefereeRequest {
    id?: number;
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicantModel?: number | undefined;

    constructor(data?: ICreateRefereeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.institution = _data["institution"];
            this.email = _data["email"];
            this.position = _data["position"];
            this.applicantModel = _data["applicantModel"];
        }
    }

    static fromJS(data: any): CreateRefereeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRefereeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["institution"] = this.institution;
        data["email"] = this.email;
        data["position"] = this.position;
        data["applicantModel"] = this.applicantModel;
        return data;
    }
}

export interface ICreateRefereeRequest {
    id?: number;
    name?: string | undefined;
    institution?: string | undefined;
    email?: string | undefined;
    position?: string | undefined;
    applicantModel?: number | undefined;
}

export class PaginatedListOfResearchExperienceDto implements IPaginatedListOfResearchExperienceDto {
    items?: ResearchExperienceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfResearchExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResearchExperienceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfResearchExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfResearchExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfResearchExperienceDto {
    items?: ResearchExperienceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResearchExperienceDto implements IResearchExperienceDto {
    id?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;
    applicant?: number;

    constructor(data?: IResearchExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.month = _data["month"];
            this.areaOfResearchIfAdmitted = _data["areaOfResearchIfAdmitted"];
            this.actualAreaOfResearch = _data["actualAreaOfResearch"];
            this.futureResearchInterest = _data["futureResearchInterest"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): ResearchExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["month"] = this.month;
        data["areaOfResearchIfAdmitted"] = this.areaOfResearchIfAdmitted;
        data["actualAreaOfResearch"] = this.actualAreaOfResearch;
        data["futureResearchInterest"] = this.futureResearchInterest;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface IResearchExperienceDto {
    id?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;
    applicant?: number;
}

export class ResearchExperienceRequest implements IResearchExperienceRequest {
    id?: number | undefined;
    applicant?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;

    constructor(data?: IResearchExperienceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.title = _data["title"];
            this.month = _data["month"];
            this.areaOfResearchIfAdmitted = _data["areaOfResearchIfAdmitted"];
            this.actualAreaOfResearch = _data["actualAreaOfResearch"];
            this.futureResearchInterest = _data["futureResearchInterest"];
        }
    }

    static fromJS(data: any): ResearchExperienceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchExperienceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["title"] = this.title;
        data["month"] = this.month;
        data["areaOfResearchIfAdmitted"] = this.areaOfResearchIfAdmitted;
        data["actualAreaOfResearch"] = this.actualAreaOfResearch;
        data["futureResearchInterest"] = this.futureResearchInterest;
        return data;
    }
}

export interface IResearchExperienceRequest {
    id?: number | undefined;
    applicant?: number;
    title?: string | undefined;
    month?: string | undefined;
    areaOfResearchIfAdmitted?: string | undefined;
    actualAreaOfResearch?: string | undefined;
    futureResearchInterest?: string | undefined;
}

export class PaginatedListOfResearchPublicationDto implements IPaginatedListOfResearchPublicationDto {
    items?: ResearchPublicationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfResearchPublicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResearchPublicationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfResearchPublicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfResearchPublicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfResearchPublicationDto {
    items?: ResearchPublicationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResearchPublicationDto implements IResearchPublicationDto {
    id?: number;
    applicant?: number;
    publication?: string | undefined;

    constructor(data?: IResearchPublicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.publication = _data["publication"];
        }
    }

    static fromJS(data: any): ResearchPublicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchPublicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["publication"] = this.publication;
        return data;
    }
}

export interface IResearchPublicationDto {
    id?: number;
    applicant?: number;
    publication?: string | undefined;
}

export class ResearchPublicationRequest implements IResearchPublicationRequest {
    id?: number;
    applicant?: number;
    publication?: string | undefined;

    constructor(data?: IResearchPublicationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicant = _data["applicant"];
            this.publication = _data["publication"];
        }
    }

    static fromJS(data: any): ResearchPublicationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResearchPublicationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicant"] = this.applicant;
        data["publication"] = this.publication;
        return data;
    }
}

export interface IResearchPublicationRequest {
    id?: number;
    applicant?: number;
    publication?: string | undefined;
}

export class PaginatedListOfResultsDto implements IPaginatedListOfResultsDto {
    items?: ResultsDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfResultsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResultsDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfResultsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfResultsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfResultsDto {
    items?: ResultsDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultsDto implements IResultsDto {
    id?: number;
    subjectID?: number;
    examType?: string;
    gradeID?: number;
    gradeOld?: number | undefined;
    gradeValueOld?: string | undefined;
    indexNo?: string;
    sitting?: string;
    month?: string;
    form?: number;
    center?: string;
    year?: string;
    oldSubject?: string | undefined;
    institutionName?: string | undefined;
    applicantModelID?: number;
    applicantModel?: ApplicantModel;
    subject?: SubjectModel;
    grade?: GradeModel;

    constructor(data?: IResultsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectID = _data["subjectID"];
            this.examType = _data["examType"];
            this.gradeID = _data["gradeID"];
            this.gradeOld = _data["gradeOld"];
            this.gradeValueOld = _data["gradeValueOld"];
            this.indexNo = _data["indexNo"];
            this.sitting = _data["sitting"];
            this.month = _data["month"];
            this.form = _data["form"];
            this.center = _data["center"];
            this.year = _data["year"];
            this.oldSubject = _data["oldSubject"];
            this.institutionName = _data["institutionName"];
            this.applicantModelID = _data["applicantModelID"];
            this.applicantModel = _data["applicantModel"] ? ApplicantModel.fromJS(_data["applicantModel"]) : <any>undefined;
            this.subject = _data["subject"] ? SubjectModel.fromJS(_data["subject"]) : <any>undefined;
            this.grade = _data["grade"] ? GradeModel.fromJS(_data["grade"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResultsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectID"] = this.subjectID;
        data["examType"] = this.examType;
        data["gradeID"] = this.gradeID;
        data["gradeOld"] = this.gradeOld;
        data["gradeValueOld"] = this.gradeValueOld;
        data["indexNo"] = this.indexNo;
        data["sitting"] = this.sitting;
        data["month"] = this.month;
        data["form"] = this.form;
        data["center"] = this.center;
        data["year"] = this.year;
        data["oldSubject"] = this.oldSubject;
        data["institutionName"] = this.institutionName;
        data["applicantModelID"] = this.applicantModelID;
        data["applicantModel"] = this.applicantModel ? this.applicantModel.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResultsDto {
    id?: number;
    subjectID?: number;
    examType?: string;
    gradeID?: number;
    gradeOld?: number | undefined;
    gradeValueOld?: string | undefined;
    indexNo?: string;
    sitting?: string;
    month?: string;
    form?: number;
    center?: string;
    year?: string;
    oldSubject?: string | undefined;
    institutionName?: string | undefined;
    applicantModelID?: number;
    applicantModel?: ApplicantModel;
    subject?: SubjectModel;
    grade?: GradeModel;
}

export class CreateResultRequest implements ICreateResultRequest {
    applicant?: number;
    subjectId?: number | undefined;
    examType?: string;
    gradeID?: number | undefined;
    indexNo?: string;
    sitting?: string;
    month?: string;
    center?: string;
    year?: string;
    institutionName?: string;

    constructor(data?: ICreateResultRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicant = _data["applicant"];
            this.subjectId = _data["subjectId"];
            this.examType = _data["examType"];
            this.gradeID = _data["gradeID"];
            this.indexNo = _data["indexNo"];
            this.sitting = _data["sitting"];
            this.month = _data["month"];
            this.center = _data["center"];
            this.year = _data["year"];
            this.institutionName = _data["institutionName"];
        }
    }

    static fromJS(data: any): CreateResultRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateResultRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicant"] = this.applicant;
        data["subjectId"] = this.subjectId;
        data["examType"] = this.examType;
        data["gradeID"] = this.gradeID;
        data["indexNo"] = this.indexNo;
        data["sitting"] = this.sitting;
        data["month"] = this.month;
        data["center"] = this.center;
        data["year"] = this.year;
        data["institutionName"] = this.institutionName;
        return data;
    }
}

export interface ICreateResultRequest {
    applicant?: number;
    subjectId?: number | undefined;
    examType?: string;
    gradeID?: number | undefined;
    indexNo?: string;
    sitting?: string;
    month?: string;
    center?: string;
    year?: string;
    institutionName?: string;
}

export class ReligionDto implements IReligionDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IReligionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ReligionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReligionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IReligionDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class RegionDto implements IRegionDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRegionDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class DenominationDto implements IDenominationDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IDenominationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DenominationDto {
        data = typeof data === 'object' ? data : {};
        let result = new DenominationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDenominationDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class ProgrammeDto implements IProgrammeDto {
    id?: number;
    name?: string;
    code?: string;
    levelAdmitted?: string;
    runing?: boolean;
    showOnPortal?: boolean;
    type?: string;
    duration?: number;
    department?: number;

    constructor(data?: IProgrammeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.levelAdmitted = _data["levelAdmitted"];
            this.runing = _data["runing"];
            this.showOnPortal = _data["showOnPortal"];
            this.type = _data["type"];
            this.duration = _data["duration"];
            this.department = _data["department"];
        }
    }

    static fromJS(data: any): ProgrammeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgrammeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["levelAdmitted"] = this.levelAdmitted;
        data["runing"] = this.runing;
        data["showOnPortal"] = this.showOnPortal;
        data["type"] = this.type;
        data["duration"] = this.duration;
        data["department"] = this.department;
        return data;
    }
}

export interface IProgrammeDto {
    id?: number;
    name?: string;
    code?: string;
    levelAdmitted?: string;
    runing?: boolean;
    showOnPortal?: boolean;
    type?: string;
    duration?: number;
    department?: number;
}

export class LanguageDto implements ILanguageDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: ILanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ILanguageDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class FormerSchoolDto implements IFormerSchoolDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IFormerSchoolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FormerSchoolDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormerSchoolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IFormerSchoolDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class DistrictDto implements IDistrictDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: IDistrictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DistrictDto {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDistrictDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class CountryDto implements ICountryDto {
    id?: number | undefined;
    name?: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryDto {
    id?: number | undefined;
    name?: string | undefined;
}

export class GradeDto implements IGradeDto {
    id?: number | undefined;
    name?: string | undefined;
    value?: number | undefined;

    constructor(data?: IGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IGradeDto {
    id?: number | undefined;
    name?: string | undefined;
    value?: number | undefined;
}

export class ExamDto implements IExamDto {
    id?: number | undefined;
    name?: string | undefined;
    cutOffPoint?: number | undefined;

    constructor(data?: IExamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.cutOffPoint = _data["cutOffPoint"];
        }
    }

    static fromJS(data: any): ExamDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["cutOffPoint"] = this.cutOffPoint;
        return data;
    }
}

export interface IExamDto {
    id?: number | undefined;
    name?: string | undefined;
    cutOffPoint?: number | undefined;
}

export class SubjectDto implements ISubjectDto {
    id?: number | undefined;
    exam?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;

    constructor(data?: ISubjectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.exam = _data["exam"];
            this.type = _data["type"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SubjectDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["exam"] = this.exam;
        data["type"] = this.type;
        data["name"] = this.name;
        return data;
    }
}

export interface ISubjectDto {
    id?: number | undefined;
    exam?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
}

export class SHSProgrammesDto implements ISHSProgrammesDto {
    id?: number;
    name?: string;

    constructor(data?: ISHSProgrammesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SHSProgrammesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SHSProgrammesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ISHSProgrammesDto {
    id?: number;
    name?: string;
}

export class PaginatedListOfTodoItemBriefDto implements IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemBriefDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TodoItemBriefDto implements ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: ITodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): TodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: PriorityLevelDto[];
    lists?: TodoListDto[];

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(PriorityLevelDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodosVm {
    priorityLevels?: PriorityLevelDto[];
    lists?: TodoListDto[];
}

export class PriorityLevelDto implements IPriorityLevelDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IPriorityLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PriorityLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data;
    }
}

export interface IPriorityLevelDto {
    value?: number;
    name?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.colour = _data["colour"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["colour"] = this.colour;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class PaginatedListOfWorkingExperienceDto implements IPaginatedListOfWorkingExperienceDto {
    items?: WorkingExperienceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfWorkingExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WorkingExperienceDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfWorkingExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfWorkingExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfWorkingExperienceDto {
    items?: WorkingExperienceDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WorkingExperienceDto implements IWorkingExperienceDto {
    id?: number;
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyAddress?: string | undefined;
    companyPosition?: string | undefined;
    companyFrom?: string | undefined;
    companyTo?: string | undefined;
    applicant?: number;

    constructor(data?: IWorkingExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.companyPhone = _data["companyPhone"];
            this.companyAddress = _data["companyAddress"];
            this.companyPosition = _data["companyPosition"];
            this.companyFrom = _data["companyFrom"];
            this.companyTo = _data["companyTo"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): WorkingExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["companyPhone"] = this.companyPhone;
        data["companyAddress"] = this.companyAddress;
        data["companyPosition"] = this.companyPosition;
        data["companyFrom"] = this.companyFrom;
        data["companyTo"] = this.companyTo;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface IWorkingExperienceDto {
    id?: number;
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyAddress?: string | undefined;
    companyPosition?: string | undefined;
    companyFrom?: string | undefined;
    companyTo?: string | undefined;
    applicant?: number;
}

export class WorkingExperienceRequest implements IWorkingExperienceRequest {
    id?: number;
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyAddress?: string | undefined;
    companyPosition?: string | undefined;
    companyFrom?: string | undefined;
    companyTo?: string | undefined;
    applicant?: number;

    constructor(data?: IWorkingExperienceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.companyPhone = _data["companyPhone"];
            this.companyAddress = _data["companyAddress"];
            this.companyPosition = _data["companyPosition"];
            this.companyFrom = _data["companyFrom"];
            this.companyTo = _data["companyTo"];
            this.applicant = _data["applicant"];
        }
    }

    static fromJS(data: any): WorkingExperienceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingExperienceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["companyPhone"] = this.companyPhone;
        data["companyAddress"] = this.companyAddress;
        data["companyPosition"] = this.companyPosition;
        data["companyFrom"] = this.companyFrom;
        data["companyTo"] = this.companyTo;
        data["applicant"] = this.applicant;
        return data;
    }
}

export interface IWorkingExperienceRequest {
    id?: number;
    companyName?: string | undefined;
    companyPhone?: string | undefined;
    companyAddress?: string | undefined;
    companyPosition?: string | undefined;
    companyFrom?: string | undefined;
    companyTo?: string | undefined;
    applicant?: number;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}